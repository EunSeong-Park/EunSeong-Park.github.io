---
title:  "[Networking 3] 애플리케이션 계층 (2)"
toc: true
tags: Networking
---

# Web & HTTP
## Web Page
잠깐 웹 페이지에 대한 기본 개념들을 숙지하고 가자. 웹 페이지는 객체(object)들의 집합이다. 객체는 HTML 파일일 수도, JPG 등의 이미지일 수도, 오디오, 자바 등일 수도 있다. 그리고 베이스(base)가 되는 HTML 파일을 가지며, 다른 여러 참조 객체들로 나누어 볼 수도 있다.

그리고 각각의 객체는 URL에 의해 주소가 할당되어있다. `호스트명 + 경로명` 과 같이 나타내어진다. 예를 들면,

> www.hello.com/yo/bro.jpg

에선 `www.hello.com`이 호스트명, `/yo/bro.jpg`가 경로명인 셈이다.

## HTTP
웹(web)의 애플리케이션 계층 프로토콜인 HTTP(HyperText Transport Protocol)은 웹 동작의 중심을 이루는 프로토콜이라 할 수 있다. HTTP는 클라이언트와 서버, 두 프로그램에 의해 구현되며, 서로 다른 두 종단 시스템에서 수행되는 서버-클라이언트 통신은 HTTP 메세지의 교환으로 이루어진다. 

HTTP는 TCP를 전송 프로토콜로 사용하여, (어느 서버-클라이언트 모델이 그렇듯) 클라이언트는 서버에게 (80번 퐅트로) TCP 연결을 요청하고, 이를 서버가 받아들이는 식으로 통신을 한다. 여기서 주목할 만한 점은, 메세지는 TCP에 의해 전송되므로 데이터 전송에서의 신뢰성을 보장한다. 그럼으로써 HTTP는 데이터의 손실이나 TCP와 하위 계층 프로토콜이 손실된 데이터를 복구하는 방법 등에 대해 고려할 필요가 없다.

HTTP의 특징 중 하나는 비상태적(stateless)이라는 점이다. HTTP 서버는 이전의 클라이언트 요청에 대한 정보를 저장하지 않는다는 의미다. 즉, (의도하든 그렇지 않든) 중복된 요청에도 요청된 만큼 서비스한다.

### HTTP Server Architecture
HTTP 서버는 스레드 이용 방식에 따라 구분할 수 있다.

#### Single-Threaded

![](/imgs/network/net9.png)

단일 메인 스레드에서 요청 수신 및 응답을 모두 수행한다. 하나의 응답에 대해 하나의 응답 구조체를 형성하여, 응답 처리가 끝나면 이를 폐기한다.

#### Multi-Threaded

![](/imgs/network/net10.png)

메인 스레드는 요청을 받고, 이를 처리하기 위해 각각의 응답마다 스레드를 생성한다. 생성된 스레드는 요청 처리 후 제거된다.

#### Thread Pool

![](/imgs/network/net11.png)

위의 경우와 마찬가지로 여러 개의 스레드를 사용하나, 고정된 숫자의 스레드로 요청들을 함께 처리하며, 각 worker 스레드는 제거되지 않는다.

### Persistence
HTTP connection에서, 단일 TCP 연결 위에서 요청 및 응답이 오가야 하는지, req-resp 쌍이 분리된 TCP 연결 위에서 보내져야 하는지에 따라 지속(persistent) 연결 HTTP와 비지속(non-persistent) 연결 HTTP로 구분할 수 있다.

#### Non-Persistent HTTP
비지속(non-persistent) 연결에서는 각각의 req-resp 쌍이 분리된 TCP 연결에서 일어난다. 여기서 연결이 어떻게 수행되는지 그 절차를 간단히 알아보자. 아래는 특정 URL:포트의 서버에게 웹 페이지를 요청하는 상황이다.

1. HTTP 클라이언트가 특정 URL:포트를 가진 HTTP 서버에 TCP 연결을 개시한다.
2. HTTP 서버는 해당 연결 요청을 받아들이고 클라이언트에게 알린다.
3. 클라이언트는 웹 페이지를 얻기 위해 TCP 연결 소켓을 통해 HTTP 요청 메세지를 보낸다.
4. HTTP 서버는 메세지를 받고, HTML를 포함한 응답 메세지를 소켓을 통해 보낸다.
5. HTTP 서버는 TCP 연결을 종료한다.
6. HTTP 클라이언트는 HTML 파일을 포함한 메세지를 받고, 이 파일을 파싱해 내부에 포함된 객체들(이미지 등)을 확인한다.
7. 나머지 내부 객체들을 받기 위해 요청을 반복적으로 수행한다.

연결이 다른 객체를 위해 유지되지 않기 때문에, 매 객체를 받을 때마다 연결이 종료된다. 각 TCP 연결은 하나의 요청 메세지와 하나의 응답 메세지만 오가는 셈이다. 비지속 연결이라 불리는 이유이기도 하다.

비지속 연결에 대해 논의할 때, 그것의 데이터 전송 시간을 측정하기 위해 RTT(Round-Trip Time)를 정의한다. RTT는 작은 패킷이 클라이언트에서 서버로 갔다가 다시 돌아오는 데 걸리는 시간이다. 이를 정확히 이해하기 위해, 파일을 요청하고 수신하는 과정을 알아야 한다.

![](/imgs/network/net4.png)

위 그림을 통해, 우리는 비지속 HTTP 응답을 받기 까지 2 x RTT + (파일 전송 시간)이 걸림을 알 수 있다.

#### Persistent HTTP
비지속 연결에는 몇 가지 문제점이 있다. 우선 객체 당 2 RTT의 시간을 필요로 하며, 각각의 TCP 연결에 의한 각종 오버헤드가 발생할 수 있다. 지속(persistent) 연결에서는 서버가 응답을 보낸 뒤에도 TCP 연결이 유지된다. 또한, 일종의 파이프라이닝으로 이전 요청에 대한 응답을 기다리지 않고 계속해서 보내는 것도 가능하다. 


### HTTP Message Format
HTTP 메세지는 요청(request)과 응답(response), 크게 두 종류가 있다.

#### Request Message
HTTP 요청 메세지는 일반 ASCII 텍스트로 쓰여있는, human-readable한 포맷이다. 각 줄은 CR(Carriage Return)과 LF(Line Feed)에 의해 구분되는데, 첫 줄은 요청 라인(request line), 이후의 줄은 헤더 라인(header line)이라 불린다. 

![](/imgs/network/net5.png)

요청 라인은 크게 세 필드로 나눌 수 있다.

- Method field : `GET`, `POST` 등의 메소드를 가진다.
- URL field : 객체의 URL 값을 가진다.
- HTTP version field : HTTP 버전을 명시한다.

이제 헤더 라인에 대해 알아보자. 

- Host : 객체가 존재하는 호스트를 명시한다. (웹 프록시 캐시에 의해 요구된다)
- Connection : 지속 연결 / 비지속 연결 등 연결 방식을 명시한다.
- User-agent : 서버에게 요청하는 브라우저의 타입을 명시한다.

그 외에도 여럿 있지만, 너무 지엽적인 내용 같아 생략하고, 더 알고 싶으면 적절한 레퍼런스를 찾아보자.

아무튼 이를 일반화한 포맷으로 나타내면 아래와 같다.

![](/imgs/network/net6.png)

#### Response Message
HTTP 응답 메세지 또한 CR과 LF에 의해 줄이 구분되며, 상태 라인(status line), 헤더 라인(header line), 그리고 데이터, 크게 세 개의 섹션으로 나눌 수 있다.

![](/imgs/network/net7.png)

요청 라인은 HTTP 버전, 상태 코드, 상태 메세지로 구성된다. `404 Not Found` 같은 메세지에서 `404`가 상태 코드, `Not Found`가 메세지다. CS 막바지 때 이것에 대한 정리를 잠깐 했었다. [참고](https://eunseong-park.github.io/cs:app/2020/02/22/CS-APP-17-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-(3).html) 

헤더 라인은 메세지 송신 후 연결 유지 여부(`Connection`), 응답 송신 시각 및 날짜(`Date`), 웹 서버 종류(`Server`) 등의 정보를 포함한다. 이것도 궁금하면 적절한 레퍼런스를 찾아보자.

### Cookies
HTTP 서버는 그것의 설계를 간단하게 하기 위해 상태를 유지하지 않는다(stateless). 하지만 필요에 따라 서버가 사용자를 제한하거나, 사용자에 맞는 컨텐츠를 제공하기 위해선 웹 사이트가 사용자를 확인하거나 추적할 수 있어야 할 수도 있다. HTTP는 쿠키(cookie)를 사용함으로써 이러한 기능을 사용할 수 있게 되었다.

쿠키 기술은 크게 네 가지 요소를 가지고 있다.

- HTTP 응답 메세지의 쿠키 헤더 라인
- 다음 HTTP 요청 메세지의 쿠키 헤더 라인
- 사용자의 브라우저에 의해 관리되는, 사용자 호스트 내의 쿠키 파일
- 웹 사이트의 백엔드(back-end) 데이터베이스

그럼, 쿠키가 어떻게 동작하는지 예시를 통해 알아보자.

- Ebay에 접속한 적이 있는 사용자가 처음으로 Amazon에 접속한다.
- Amazon 서버는 유일하게 식별되는 ID를 생성하고, DB에 그 ID로 인덱스되는 엔트리를 생성한다.
- HTTP 응답에 해당 ID를 포함하여 전송한다. (`Set-cookie: (ID)`)
- 이후 사용자의 HTTP 요청은 해당 ID를 포함하는 헤더를 삽입하여 보내어진다. (`Cookie: (ID)`)
- 서버는 일반적인 HTTP 응답 메세지를 보낸다.

이러한 방식으로, 서버는 특정 ID의 사용자의 활동을 추적할 수 있다. 쿠키는 이러한 방식으로 사용자 인증, 장바구니 기능, 상품 및 서비스 추천 등 다양한 기능을 제공할 수 있지만, 그러면서도 개인 정보의 제3자 제공 등 사용자 개인 정보에 대한 issue도 발생한다.

### Web Caches (Proxy Server)
웹 캐시(web cache), 또는 프록시 서버(proxy server)는 기점이 되는 서버(origin server)의 개입 없이 클라이언트의 요청을 수행할 방법을 제공한다. 또한 이는 자체 저장 공간을 가져, 최근 호출된 객체의 카피를 저장 및 보존한다. 예시로 어떤 클라이언트가 어떤 객체를 요구하는 상황을 생각해보자.

1. 클라이언트가 어떤 객체를 요청한다.
2. 프록시 서버는 객체가 캐시되었는지 확인한다.
3. 캐시되어있지 않다면, origin 서버에게 객체를 요청해 객체를 가져온 다음, 다시 2번으로 돌아간다.
4. 캐시되어 있다면 프록시 서버 측에서 클라이언트에게 (객체를 포함하여) 응답한다.

여기서 주목할 점은, 프록시 서버는 서버 역할과 클라이언트 역할 모두를 수행한다는 점과, 클라이언트는 직접 origin server와 상호작용하지 않는다는 점이다. 아무튼 이러한 프록시 서버의 사용은 여러 측면에서 상당히 유용하다.

1. 클라이언트 요청에 의한 응답 시간을 상당히 줄일 수 있다. 
2. 어떤 기관의 접속 링크에서의 웹 트래픽을 줄여준다.
3. 클라이언트와 서버 간의 직접 상호작용보다 안전하다.

이제, 구체적인 예시를 통해 웹 캐싱이 어떤 이점을 가져다주는지 알아볼 것이다.

#### Web Caching Example
아래와 같은 상황을 가정해보자.

![](/imgs/network/net8.png)

- 접속률 1.54 Mbps
- 기관 내 라우터에서 origin 서버로의 RTT : 2 초
- 평균 요청 비율 : 초당 15회
- 브라우저로의 평균 data rate : 1.50 Mbps
- 평균 객체 크기 : 100K bit

이 경우, 액세스 링크는 99% 수준의 utilization이 일어난다. 총 지연 시간은 `인터넷 지연` + `액세스 지연` + `LAN 지연` 으로 볼 수 있는데, 액세스 딜레이에서 굉장히 큰 지연이 일어날 것이다. 이 상황을 어떻게 해결할까?

첫 번째 방법으론 접속률을 올리는 것이다. 1.54 Mbps 였던 접속률을 100배 늘리면, 액세스 링크의 utilization은 1%에 가깝게 떨어져 액세스 지연을 없는 수준처럼 만들어낼 수 있다. 다만 여기엔 치명적인 문제가 있는데, 접속률을 높이기 위한 비용은 만만치 않다는 점이다.

두 번째 방법으론 로컬 캐시를 설치하는 것이다. 캐시 적중 비율을 0.4로 가정하자. 40%의 요청은 캐시되어 있으므로 즉시 만족되며, 나머지는 액세스 링크를 통해 origin 서버에게 가야 한다. 그럼에도 트래픽 강도는 확연히 줄어 매우 작은 지연으로 처리할 수 있다. 그러면서도 인터넷 회선을 증설할 필요 없이 비교적 저렴한 캐시를 설치할 수 있다.

#### Conditional GET
가령 클라이언트가 객체를 얻기 위해 `GET` 메소드를 사용했을 때, 프록시 서버에 __최신 상태__ 의 객체가 캐시되어 있다면 그것을 바로 클라이언트에게 보내주면 된다. 여기서 문제는, 최신 상태(up-to-date)인지의 여부를 확인해야 한다는 점이다. 

HTTP는 클라이언트가 브라우저로 전달되는 모든 객체들이 최신 상태임을 확인하면서 캐싱하도록 한다. 클라이언트가 HTTP 요청 시, _어느 날짜 이후로 수정된 객체만을 받는다_ 고 명시하는 헤더(`If-modified-since: (Date)`)를 붙여 메세지를 전송한다. 이 때, 캐시된 카피가 최신 상태라면, 응답이 데이터를 포함하지 않고 내용이 변경되지 않았음을 알린다(`304 Not Modified`). 만약 그렇지 않다면, 정상적으로 데이터를 가져와 응답 메세지에 포함시켜 전달한다(`200 OK`)

