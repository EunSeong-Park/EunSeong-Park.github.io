---
title:  "[Networking 5] 애플리케이션 계층 (4)"
toc: true
tags: Networking
---

# Intro
오늘이 애플리케이션 계층 마지막이(었으면 좋겠)다. 여러 네트워크 애플리케이션과 그것의 기저에 있는 프로토콜 등을 알아보도록 하자.


# P2P
P2P에 관한 개념은 저번에 짚고 넘어갔었다. _Always-on_ 서버가 없고, 피어(peer)라 불리는 여러 종단 시스템(end system) 간 직접적인 통신을 수행한다. 비트토렌트(BitTorrent), 스카이프(Skype)와 같은 애플리케이션이 다 이를 기반으로 한다.

## File Distribution
클라이언트-서버 모델과 P2P 모델에서의 (다수로의) 파일 전송 방식은 어떻게 다르고, 어떤 게 어떤 상황에서 더 효율적일까? 한 번 알아보도록 하자.

클라이언트-서버 통신에서는 서버가 다수의 클라이언트에게(N이라고 하자) 파일을 보내려면, N회의 카피(또는 업로드)를 필요로 한다. 즉, 크기가 `F`인 파일을 대역폭 `u`로 보내려면, `NF/u`의 시간을 필요로 한다. 클라이언트의 입장에선 그 파일의 다운로드 시간(`F/d`)(그 중에서 가장 느린 클라이언트를 고려한다), 또는 자신에게 올 파일의 업로드 시간 중 하나가 constraint가 될 것이다.

P2P 통신에서는 파일 전송을 위해 (file distribution을 위한) 서버가 한 번 (또는 그 이상) 파일을 업로드 해야 한다. 즉 여기선 `F/u`의 시간이 소요되는 셈이다. 그리고 클라이언트는 파일을 `F/d`의 시간을 소요해 다운로드한다. 여기서 고려해야 할 게 하나 더 있는데, 시스템은 모든 피어에 `F`만큼을 전달해야 하고, 파일 업로드를 위해 피어가 그 과정에 참여할 수 있다. 그 속도는 최대 `u_server + u_peer_total`이므로, `NF/u_total`도 constraint가 될 수 있다.

이 두 과정은 분배해야 하는 대상의 수(N)가 많을 수록 그 차이가 드러나는데, 클라이언트-서버 구조에서는 분배 시간이 linear하게 증가하지만, P2P는 linear한 팩터가 마찬가지로 존재함에도 불구하고, 피어들의 분담으로 인해 선형적으로 증가하진 않는다.

![](/imgs/network/net15.png)

## BitTorrent
비트토렌트(BitTorrent)도 파일 분배를 위한 P2P 프로토콜 중 하나다. 다양한 종류의 비트토렌트 클라이언트가 존재하며, 우리에게 여러 의미에서 친숙한 uTorrent 또한 비트토렌트 클라이언트다.

어떠한 파일에 대해, 그 파일의 분배에 참여하는 피어들의 그룹을 토렌트(torrent)라 부른다. 토렌트에선 파일이 256KB의 chunk로 쪼개져, 피어들은 그 청크들을 보내거나 받는다. 각 토렌트엔 트래커(tracker)가 있어, 토렌트에 참여한 피어들을 추적할 수 있고, 피어들 또한 트래커에게 자신이 토렌트에 있음을 알릴 수 있다. 

어떤 토렌트에 참여해 파일을 받는 상황을 생각해보자. 처음 들어왔을 때, 트래커는 이미 토렌트에 참여 중인 피어들의 일부를 선택해 그들의 IP를 참여자에게 보낸다. 그러면 참여자는 피어들 각각과 (3-way handshake 등을 포함한) TCP 연결을 설정해 파일 공유를 시작한다. 연결되는 피어는 시간에 따라 (많아지든 적어지든) 달라질 수 있다. 특정 시점에, 참여자를 포함한 피어들은 데이터 청크의 일부 또는 전체를 가지고 있을 것이다. 파일을 받기 위해, 다운로더는 필요한 파일 청크의 소유자를 찾고, 그에게 청크를 요청한다. 파일을 주고 받는 과정엔 몇 가지 기법이 사용되는데,

- 다운로더는 피어들이 가장 적게 소유하고 있는 청크를 가장 먼저 요구한다(rarest-first). 그럼으로써 토렌트 내에서 희귀한 청크가 보다 많아지며 청크 전체가 전반적으로 고른 속도로 분배될 수 있다.
- 청크를 공유할 땐 공유자에게 가장 빠른 속도로 데이터를 제공하는 피어를 일부(4) 선택해 그들에게 우선적으로 청크를 제공한다(tit-for-tat). 이는 주기적으로(10초) 갱신되는데, 또 조금 더 긴 주기로(30초) 무작위 대상을 뽑아 그에게도 청크를 제공한다. 이로써 총 다섯 피어에게 청크를 제공하는 셈이다.

비트토렌트에 대한 전반적인 구조와 과정을 살펴보았는데, 토렌트 클라이언트를 켜놓고 Wireshark 등을 통해 패킷을 분석하면 꽤 유용한 정보들을 알아볼 수 있다.

# Video Streaming & CDN
비디오 트래픽은 인터넷 대역폭의 주 소비자라고 한다. 비디오 자체의 용량도 크고, 어느 정도의 속도를 보장해야 하는데, YouTube나 NETFLIX와 같은 대형 플랫폼엔 항상 사람이 붐빈다. 이러한 비디오 스트리밍 서비스에선 몇 가지 challenge가 있다.

- Scalability : 대용량의 데이터를 대규모의 사용자에게, 문제 없이 전달하려면 어떻게 해야 할까?
- Heterogeneity : 다양한 사용자가 있고, 그들은 각기 다른 (대역폭 등의 측면에서의) capability를 가진다. 이러한 차이를 어떻게 처리할까?

그 전에, 몇 가지 사전지식을 짚고 가자.

## Video
모두가 알고 있겠지만, 비디오(video)는 일정한 속도로 재생되고 보여지는 이미지의 시퀀스다. 그리고 이미지는 픽셀에 대한 컬러의 배열로 나타낼 수 있다.

대부분의 비디오는 목적과 기기 등에 맞게 인코딩되는데, 인코딩은 단순히 화질이나 frame rate을 낮추는 등의 작업뿐 아니라, 다른 추가적인 작업으로도 그것의 용량을 낮출 수 있다.(물론 인코딩이 용량 감소만을 목적으로 하진 않는다)

- Spatial : 특정 시점의 이미지 배열 내에 동일 색상의 중복된 시퀀스가 있다면, 색상에 해당하는 비트와 시퀀스의 길이만으로 그 영역을 표시하여 사용되는 비트를 줄인다. (특정 프레임 이미지 내에서 작동)
- Temporal : 어떤 프레임으로부터 다음 프레임으로 넘어갈 때, 전체를 저장하지 않고 프레임에 걸쳐 변화가 생긴 위치의 정보만을 저장한다. (여러 프레임 사이에서 작동)

또 중요한 개념으로 비트레이트(bitrate)가 있다. (비디오든 사운드든) 특정 시간 동안 재생하는 데 필요한 비트 수를 의미하는데, 이는 시간에 걸쳐 고정되었을 수도(CBR), 가변적일 수도(VBR) 있다. Spatial/temporal coding이 적용되었다면 특정 프레임 구간을 구성하는 이미지에 의존하므로 가변적일 것이다. 단위론 주로 bps(bits per sec)를 사용한다.

## DASH (Dynamic Adaptive Streaming over HTTP)
DASH는 HTTP에서 전송되거나 이를 경유하는 미디어의 스트리밍을 위한 기술이다. 서버는 비디오 파일을 서로 다른 비트레이트로 인코딩되는 다수의 청크로 분할하여 저장하며, 각각에 URL을 할당한다. 클라이언트는 주기적으로 server-to-client의 대역폭을 측정하고, 그에 따라 청크를 요청하여 받는다.

클라이언트의 역할이 꽤 중요한데, 클라이언트는 언제 청크를 요청할지, 청크의 encoding rate를 어느 정도로 할지, 누구에게 청크를 요청할지 등을 능동적으로 결정하여 요청한다. 이로써 최대한 빠르게, 가능한 한 높은 품질로, 기타 문제(overflow, buffer starvation 등)를 최소화하여 청크를 요청하게 된다. 이러한 사항은 서버로부터의 대역폭, 클라이언트의 상태 등을 통해 결정한다.

## CDN (Content Distribution Networks)
그래서, 비디오를 대규모 사용자에게 어떻게 문제 없이 동시다발적으로 제공할 수 있는가? 

단일 대규모 서버를 사용하지 않고 분산시키는 건 몇 가지 치명적인 문제를 야기한다. 결국은 확장성(scalability)의 문제다.

- 오류 및 고장은 서비스에 치명적으로 작용한다.
- 먼 위치의 사용자는 반드시 존재하고, 고른 품질의 서비스를 제공하는 데 어려움이 있다.
- 네트워크 혼잡(congestion)의 우려가 있다.

CDN(Content Distribution Network)은 컨텐츠를 저장하는 origin 서버와 사용자 사이에서 컨텐츠의 캐시 역할을 한다. CDN 서버는 기본적으로 오리진 서버에 비해 가까워 빠르게 응답할 수 있고, 대용량의 컨텐츠를 그곳에서 전달하기 때문에, 오리진 서버 또한 다수의 사용자에 대한 부담이 적다. CDN을 사용하는 모델은 보통 다음과 같은 절차를 통해 컨텐츠를 제공한다.

1. (DNS 매핑 등을 전부 완료하고) 사용자는 서버에 컨텐츠를 요청한다.
2. 서버는 컨텐츠 대신 CDN 서버 내의 컨텐츠에 대한 URL을 제공한다.
3. 사용자의 로컬 DNS 서버는 그 URL을 해석하여 CDN 서버에게 컨텐츠를 요청한다.
4. CDN 서버는 사용자에게 직접 컨텐츠를 제공한다.

NETFLIX도 CDN을 활용해 스트리밍을 제공한다.

![](/imgs/network/net16.png)


# 마치며
다음은 소켓 프로그래밍에 대해 짚고 넘어가자. CS:APP에서도 살짝 짚고 넘어갔지만, 더 자세히 알아볼 예정이다.
