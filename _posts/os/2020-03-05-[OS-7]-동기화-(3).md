---
title:  "[OS 7] 동기화 (3)"
tags: OS
toc: true
---

# Intro
요새 OS 수업을 좀 쨌더니 공부할 게 많이 밀렸다..


# Classical Problems of Synchronization
여러 동기화 기법들에 대해 생각해볼 수 있는 고전적인 문제들이 있다. 잘 설계된 동기화 기법이라면 다음과 같은 문제들을 해결할 수 있고, 그래야 할 것이다. 우리는 앞서 세마포어를 동기화 도구로서 사용하였는데, 세마포어(semaphore)는 이러한 문제들을 잘 해결해주는지, 만약 그렇다면 어떻게 해결해주는지 알아보도록 하자.

## Bounded-Buffer Problem
**유한버퍼(bounded-buffer) 문제**는 다수의 생산자(producer)와 소비자(consumer)가 한정된 공간의 버퍼로의 접근을 시도할 때 생기는 문제다. 예를 들어, 어떤 버퍼에 저장된 양을 나타내는 공유 변수가 있다고 가정하자. 동기화가 제대로 이루어지지 않으면, 공유 변수가 꼬여 실제 저장된 데이터의 양을 잘 반영하지 못하거나, **꽉 찬 버퍼에 쓰거나 빈 버퍼를 읽는 등**의 문제가 발생할 수 있다.

세마포어를 이용해 이러한 문제를 해결해보자. 하나의 아이템을 저장할 수 있는 $n$개의 버퍼 pool을 가정한다. `mutex` 세마포어는 버퍼 풀에 접근하기 위해 상호 배제(mutual exclusion)를 제공하고, 이들은 $1$로 초기화된다(처음엔 비었으므로 이용 가능하기 때문에). 또, 빈 버퍼 수와 꽉 찬 버퍼 수를 나타내는 `empty`와 `full` 세마포어를 도입하고, 이들을 각각 $n, 0$으로 초기화한다. 이럼으로써 생산자/소비자는 철저히 상호 배제가 적용된 채로 접근하게 되며, 유효하지 않은 접근을 막을 수 있다.

## Readers-Writers Problem
어떤 데이터베이스에 대하여, 읽기만 하는 대상과 읽고 쓸 수 있는 대상이 있을 것이다. 전자를 **reader**, 후자를 **writer**라 하자. 다수의 reader의 동시적인 접근은 별 문제가 되지 않지만, 여기에 writer가 포함되어 있을 경우 예상치 못한 결과가 나올 수 있다. 여기선 단순한 상호 배제만을 적용하면 안되는데, 그것은 reader나 writer의 **starvation**에 대한 가능성 때문이다. Writer가 접근 권한을 얻지 못한 상황에서, 어떤 reader가 다른 reader의 읽기가 끝나기를 기다리면 어떻게 될까? Writer는 starvation이 발생할 수 있다. (Reader의 starvation과 해결 방법은 적지 않았다)

이 문제를 해결하기 위해 `mutex`와 `wrt` 두 세마포어를 도입해보자. `mutex`는 현재 읽고 있는 reader의 수를 갱신할 때 상호 배제를 적용하기 위한 세마포어고, `wrt`는 writer의 상호 배제를 위한 세마포어다. Writer가 critical section에 들어와 있으면 reader들은 대기하며, 다수의 reader가 읽고 있을 때, `mutex`에 의해 동기화된 reader의 수가 $0$이 되었을 때만 `wrt`를 넘겨주어 writer가 쓰기를 수행할 수 있도록 한다.

## Dining-Philosophers Problem
[식사하는 철학자들 문제](https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C)

설명하기 귀찮으므로 위키를 보자... 아무튼 이는 교착(deadlock) 또는 기아(starvation)를 유발할 수 있다. 이를 해결하기 위해 젓가락을 집는 행위에 대해 상호 배제를 적용하거나, 젓가락을 집는 방식에서 대칭성을 제거하거나, 철학자(접근자)의 수를 제한하는 등의 방법으로 해결할 수 있다. 여기에서 중요한 점이 하나 있는데, **교착을 해결한다고 해서 기아가 발생하지 않는다는 게 보장되지는 않는다.** 교착과 기아를 모두 발생시키지 않도록 하기 위해, 우리는 이와 같은 공유 자원에 대한 접근에서 다양한 경우를 생각해 보아야 한다.


# Condition Variable
**조건 변수(condition variable)**란, 특정 조건을 만족하길 기다리는 변수를 의미한다. 이름이 참 직관적이다. 보통 세마포어와 같은 동기화 도구와 연계 해, 상호 배제를 더욱 정교하고 효과적으로 사용할 수 있게 한다. 조건 변수는 특정 조건을 만족할 때까지 스레드를 블록할 수 있고, 조건 만족 시 하나 혹은 모든 스레드를 깨울 수 있다. 이는 여러 측면에서 유용한데, 기존의 mutex는 다른 스레드가 언제 mutex를 해제했는지 알기가 어려운 데 반해, 조건 변수의 도입으로 mutex 해제 시 다른 스레드에게 시그널로 알리고, 다른 스레드는 그 시그널을 기다림으로써 이 문제를 해결할 수 있다. 여기서 말하는 시그널은 일반적인 의미의 시그널이 아님을 유의하자.

CV의 중요한 특성이 몇 가지 있다. 우선 CV는 **memoryless**해서, 대기 중인 스레드의 대기열을 제외한 어떤 내부 정보도 저장하지 않는다. 즉, 이전의 시그널과 관련된 함수 호출에 대한 정보를 기억하지 않고, 시그널을 보내는 행위의 effectiveness는 스레드가 대기열에 비어있지 않은지의 여부에만 의존한다. 또, 시그널에 대한 `wait`은 while loop로 돌려도 안전하다. 시그널 수신 여부를 확인하기 위해 while loop로 돌려서 recheck하자. 그리고 시그널의 방향성을 확실히 설정해야 한다. 아래의 상황에서는 생산자에서 소비자로, 혹은 소비자에서 생산자로 시그널이 전송되어야 한다.

CV를 이용해 bounded-buffer 문제를 해결해보자. 두 CV empty/full를 도입하여, 생산자는 버퍼로의 저장 전에 `full.wait(lock)`을 통해 시그널을 기다린다. 이후 쓰기 후엔 버퍼가 비어있지 않으므로 `empty.signal(lock)`을 통해 시그널을 보낸다. 소비자도 마찬가지로, `empty.wait(lock)`을 통해 버퍼가 비어있지 않기를 기다린다. 이후 아이템을 소비한 뒤엔 버퍼가 꽉 차있지 않으므로 `full.signal(lock)`을 통해 시그널을 보낸다.


# Monitor
**모니터(monitor)**는 특정 시점에서 오직 하나의 프로세스만이 모니터 내에서 활성화 될 수 있도록 하는 ADT(Abstract Data Type)로, 모니터 내부의 변수들은 내부 프로시저에 의해서만 접근될 수 있도록 캡슐화(encapsulation)한다. 상당히 high-level의 추상화가 적용된 모델이기 때문에, 프로그래머는 동기화의 제약 조건을 명시적으로 구현할 필요가 없다. (하지만 그런 만큼 부가적인 기법이 없으면 충분히 강력하지 않다) 우리는 조건 변수를 모니터 내에 도입함으로써 동기화 방식을 개선할 수 있다.

이를 이용해 Dining Philoshopher 문제를 해결해보자. "양 쪽 젓가락을 모두 집을 수 있을 때만 젓가락을 집는다"라는 조건을 추가하여 교착을 해결한다. 다섯 철학자를 각각 `{Thinking, Hungry, Eating}` 세 상태로 나누어 보자. i-th 철학자는 두 이웃이 `Eating`이 아닐 때만 `Eating`으로 설정될 수 있을 것이다. 여기서 조건 변수 `condition`을 추가하여, 자신이 `Hungry`할 때 젓가락을 집을 수 있을 때까지 `wait`로 대기한다. `Eating`이 완료되면 `putdown`으로 스스로를 `Thinking`으로 전환하여, 이웃한 철학자가 식사를 할 수 있도록 한다.

![](/imgs/os/os19.png)

하지만 이는 기아가 전혀 발생하지 않음을 보장하진 못한다. 왜 그런지와 어떻게 해결할지는 나중에 알아보자.

그런데, 다수의 프로세스가 큐에 놓여져 있고, 그 상황에서 시그널이 날아오면 누가 그 시그널을 받고 재개되어야 할까? FIFO를 따르는 게 꽤 직관적이지만, `wait(priority)`를 통해, 우선순위를 부여하는 conditional-wait로 더욱 효과적으로 제어할 수 있다. 이러한 방법은 공유 자원에 대한 접근의 최대 시간 등을 설정할 수 있도록 하는 등 여러 측면에서 유용하다.


# 마치며
좀 막쓴 것 같다. 아무튼 다음엔 교착(deadlock)에 대해 알아보고, 이를 해결하기 위한 솔루션들도 살펴보자.






