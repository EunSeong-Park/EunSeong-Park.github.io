---
title:  "[OS 11] 저장장치와 파일 시스템"
tags: OS
toc: true
---

# Intro
오랜만에 OS를 정리해본다. 

모두가 알겠지만, HDD과 같은 자기 디스크(magnetic disk)나 SSD와 같은 플래시 메모리(flash memory)는 고용량이지만 낮은 속도의 접근을 제공한다. 하지만 단순히 용량/접근 속도뿐만 아니라, 다른 메모리와의 중요한 차이점이 몇 가지 있다. 파일(file)이라는 개념과 그것을 다루는 시스템의 존재가 바로 그것이다.

이번엔 저장장치가 어떤 특성을 가지는지, 그리고 그러한 저장장치에서 이루어지는 파일 시스템이 어떻게 동작하는지 알아볼 것이다.


# Storage System
먼저 저장장치의 특성을 알아야 파일 시스템에 대한 이해를 제대로 할 수 있다. 

## Magnetic Disk

![](/imgs/os/os35.png)

자기 디스크는 다수의 플래터(platter)와 이를 회전시키는 스핀들(spindle), 그리고 데이터를 읽을 헤드(head)와 이를 움직일 암(arm)으로 구성되어 있다. 한 플래터는 두 개의 서피스(surface)를 가지고, 한 서피스에는 다수의 원형 트랙(track)이, 각 트랙은 다수의 섹터(sector)가 있다.  또, 특정 반지름을 가진 트랙의 스택을 실린더(cylinder)라고 한다.

![](/imgs/os/os36.png)

암이 움직이면서 주어진 서피스에서의 트랙을 결정하고, 디스크가 회전하면서 정확한 섹터를 결정한다. 이 땐 상당한 딜레이가 발생하는데, 그 딜레이를 크게 세 요소의 합으로 볼 수 있다.

- Rotational time: 디스크가 회전하며 원하는 섹터에 도달하기까지 걸리는 시간
- Seek time: 암이 원하는 트랙에 도달하기까지 걸리는 시간
- Transfer time: 섹터에 도달했을 때, 이를 지나는 데 걸리는 시간

Seek와 rotation은 상당히 오래 걸리고, transfer는 그에 비해 상대적으로 빠르다. 그러한 측면에서, 디스크에서의 random access는 상당한 지연을 발생시킬 것이다.

### Seek
Seek time은 크게 네 구간으로 나누어진다.

- Speedup: 암을 최대 속도로, 혹은 목적지의 중간에 도달할 때까지 가속시킨다.
- Coast: 최대 속도를 유지한다.
- Slow down: 목적지에서 암을 멈춘다.
- Settle: 목적지 트랙에 헤드를 정확히 맞춘다.

Seek time은 상대적으로 오래 걸린다. 몇 십 ms가 소요될 수도 있다. 가능하면 불필요한 암의 움직임을 최소화 하고, 특정 track에 연속적으로 저장하는 등의 노력을 하는 게 좋다.

### Rotation
Rotation time은 그것의 RPM에 의존한다. 로테이션을 시작하자마자 섹터에 도달할 수도 있고, 거의 한 바퀴를 돌아야 섹터에 도달할 수 있는 경우도 있다. 그리하여 로테이션은 실제 한 바퀴 돌리는 시간의 절반을 평균으로 잡는다.

### Transfer
이 또한 로테이션을 수반하므로 RPM에 의존하고, 섹터의 밀도에도 의존한다. 밀도가 클 수록 같은 데이터를 읽는 데 시간이 더 적게 소요될 것이다.

### Example

- 1 Sector: 512 B
- Seek time: average 10.5 ms
- Rotation time: average 4.15 ms (7200 RPM)
- Transfer: 4 us

위와 같은 상황에서, 500개의 섹터를 random/sequential access로 읽고, 각각의 수행 시간을 비교해보자.

- Random access: $500 * (10.5 + 4.15 + 0.004) = 7300 ms $
- Sequential access: $10.5 + 4.15 + 0.004 * 500 = 16.7 ms $

무려 437배나 차이난다..!

### Disk Scheduling
디스크 스케줄러(scheduler)는 어떤 I/O 요청을 먼저 수행할지를 결정한다. 위에서 볼 수 있듯이, 스케줄링은 디스크 읽기의 성능에 큰 영향을 끼칠 수 있을 것이다.

가장 간단한 방법은 FCFS(First Come First Served)다. 먼저 들어온 요청을 처리하는 방식인데, 이는 구현이 간단하지만, 요청에 해당하는 트랙, 실린더의 분포가 나쁘다면 성능을 크게 떨어뜨릴 수 있다.

![](/imgs/os/os37.png)

이에 대한 대안으로, 마지막 요청으로부터 가장 가까운 요청을 처리하는 SSTF(Shortest Seek Time First), 혹은 SPTF(Shortest Positioning Time First)라는 방법이 있다. 

![](/imgs/os/os38.png)

이 방법은 분명히 FCFS 방법보다 괜찮은 성능을 보여주는 것 같지만, 일부 디스크 요청이 매우 오래 기다리게 되는 기아(starvation)가 발생할 수 있다는 단점이 있다. 예를 들어, 헤드가 50에서 시작할 때, 요청 분포가 30-70 정도에 쏠려있고, 190에서의 요청이 단 하나 있다면, 그 요청은 굉장히 많은 시간을 기다려야 할 것이다.

마지막으로, SCAN 스케줄링 기법을 알아보자. SCAN 스케줄링에선 암이 디스크 끝 쪽에서 시작하여, 가는 길에 있는 요청을 모두 처리하고, 끝에 도달하거나 그 길에 더 이상 요청이 남아있지 않다면 방향을 바꾸는 식으로 요청을 처리한다. 그래서 헤드는 디스크 양쪽을 계속해서 왕복한다. 이러한 방법은 지역성을 잘 살려주고, 모든 요청의 대기 시간이 bounded되어 기아가 발생하지 않는다는 단점이 있다. 하지만 가운데 실린더가 요청이 더 잘 이루어지는 unfairness가 분명 존재한다.

## Flash Memory
SSD와 같은 플래시 메모리는 자기 디스크에 비해 더욱 빠른 읽기/쓰기 속도, 더 큰 대역폭을 가진다. 동작 방식에서도 자기 디스크와 몇 가지 차이점을 보인다.

우선, 쓰기는 반드시 clean cell에서 이루어진다. 즉, in-place update가 불가능하며, 쓰기 전에 블록을 지워야할 수 있다. 또, 그러한 erasure는 상당한 시간이 소요된다. (ms 단위) 이러한 특성으로, 쓰기는 읽기에 비해 상당히 느리게 동작한다.

예를 들어, 블록 사이즈가 4 페이지인 어떤 플래시 메모리에서, Page 0에 "00000011"을 덮어 쓴다고 가정해보자. 플래시 메모리는 해당 블록 전체를 지우고, Page 0을 새로 쓴다.

![](/imgs/os/os40.png)

SSD는 가상 논리 블록(virtual logical block)과 실제 플래시 메모리 위치 사이의 매핑 정보를 가진다. HDD는 실제 드라이브와 OS 관점이 정확히 대응되지만, SSD는 그렇지 않은 셈이다.

![](/imgs/os/os39.png)

소프트웨어는 logical block address를 통해 플래시에 접근하고, 이는 적당히 매핑되어 실제 플래시 주소가 되어 플래시 메모리 내에서 처리된다. 이러한 역할은 FTL(Flash Translation Layer)에서 수행된다.

![](/imgs/os/os41.png)


# File System
이제 본격적으로 파일 시스템에 대해 알아보자. 파일 시스템을 바람직한 방향으로 설계하기 위해, 파일과 파일 시스템의 특성을 명확히 이해해야 한다.

우리는 파일 시스템을 설계하기 위해 다음과 같은 사항을 목표로 해야 한다.

- 가능한 한 디스크 접근을 최소화해야 한다.
- 저장장치의 특성을 고려하여 설계해야 한다.
- 오버헤드(특히 공간에 관한)를 최소화하는 방향으로 설계해야 한다.


## File
우리는 분명히 파일(file)과 데이터(data)의 의미를 구분한다. 예를 들어, 메인 메모리에 저장된 정보를 데이터라고는 하지만, 파일이라고 하지는 않는다. 파일의 의미는 정확히 뭘까?

파일은 간단히 말하면, 디스크에 기록된 명명된(named) 바이트 집합으로 볼 수 있다. 주체에 따라 파일을 약간 다르게 해석할 수 있다. 가령 사용자는 명명된 바이트 시퀀스로 보겠지만, 파일 시스템은 디스크 블록의 집합으로 여길 것이다. 여기서 파일 시스템은 사용자에 의해 지정된 파일과 파일 내에서의 오프셋을 실제 디스크 블록으로 매핑하는 역할을 수행해야 한다.

OS에 따라 다르지만, 대체로 파일은 다음과 같은 속성들을 포함한다.

- 이름
- 식별자(identifier): 파일 시스템에서 파일을 식별하기 위한 숫자
- 타입
- 크기
- 위치
- 보호 (접근 제어 정보): 읽기/쓰기/실행 권한 등
- 사용자 식별 정보: 최근 변경, 마지막 수정 시간 등

또, 파일에 대해 다음과 같은 기본적인 연산을 수행할 수 있다. 시스템에 따라 appending, renaming 등 추가적인 연산을 지원할 수 있다.

- 파일 생성(creation): 파일을 저장할 공간을 탐색하는 과정과 파일에 대한 항목들을 디렉터리에 생성하는 과정을 포함한다.
- 파일 쓰기: 주어진 파일 이름을 통해 디렉터리에서 해당 파일을 찾고, 파일 위치 포인터를 기준으로 쓰기를 수행한다. 
- 파일 읽기: 주어진 파일 이름을 통해 디렉터리에서 해당 파일을 찾고, 파일 위치 포인터를 기준으로 파일을 읽어낸다.
- 위치 재설정(reposition): 현재 파일 위치를 재설정한다. 
- 파일 삭제: 주어진 파일 이름을 통해 디렉터리에서 해당 파일을 찾고, 그 파일이 차지하는 모든 공간을 free하고 해당 항목을 디렉터리에서 삭제한다.
- 파일 절단: 파일의 속성을 유지한 상태로 내용만을 지운다. 파일이 차지하는 공간은 해제되고 길이는 0이 된다.

## Directory
다양한 종류와 목적을 가진 수많은 파일들은 어떤 디렉터리에 속하게 된다. 디렉터리는 그것에 속한 파일에 대하여, 파일 이름을 해당 디렉터리 항목(즉, 파일의 메타데이터)으로 매핑해주는 데이터 구조로 볼 수 있다. ( __그리고 이 또한 파일의 일종이다.__ ) 파일 식별자는 실제 저장장치의 블록에 매핑하기 위한 중요한 메타데이터다. 디렉터리가 지원하는 (또, 지원해야하는) 다양한 연산이 있고, 그러한 연산을 수행할 수 있다는 전제 하에 디렉터리의 데이터 구조나 형태는 다양한 방식으로 정의될 수 있다.

디렉터리에는 다음과 같은 연산들이 수행될 수 있다.

- 파일 탐색: 디렉터리 구조에서 사용자는 특정 파일에 해당하는 메타데이터를 찾을 수 있다.
- 파일 생성: 새로운 파일을 생성하고, 이를 디렉터리에 추가한다.
- 파일 삭제: 파일을 디렉터리에서 삭제한다.
- 디렉터리 나열: 디렉터리에 존재하는 파일들을 나열하고, 파일들에 대한 메타데이터를 보여준다.
- 파일 재명명: 파일의 이름을 변경한다. 이는 디렉터리 구조 내에서의 위치 변경을 수반할 수도 있다.
- 파일 시스템 순회: 파일 시스템의 모든 디렉터리를 순회하면서 그 안의 모든 파일에 대해 액세스한다.

앞서 언급했듯, 시스템에 따라 디렉터리 구조가 다를 수 있다. 예를 들어, 모든 사용자에게 동일하게 적용되는, 서브 디렉터리가 없는 single-level 디렉터리가 있는가 하면, 서브 디렉터리는 여전히 없으나 사용자 각각이 고유의 디렉터리를 가지는 two-level 디렉터리도 있다. 또는, (우리가 자연스럽게 사용하는) 다단계 트리(그리고 그에 따른 서브 디렉터리의 존재)로 구성된 tree-structured 디렉터리도 있다. 사용자 간 파일 공유를 위해서 한 비순환/순환 그래프 디렉터리도 있다. 이들에 대한 디테일한 구조와 구현 문제는 생략한다.

## Index Structure
디렉터리는 주어진 파일 이름을 실제 파일의 메타데이터로 매핑한다. 메타데이터는 파일 번호(식별자)를 포함한다. 이제 주어진 파일 번호와 오프셋으로 실제 저장장치의 블록을 찾아야 한다. 이 역할은 index structure에 의해 수행된다.

![](/imgs/os/os42.png)

디렉터리와 마찬가지로, index structure는 다양한 종류의 데이터 구조를 가질 수 있다.

### Linked File
`inode`라 불리는 메타데이터는 파일의 첫 블록을 가리킨다(point). 이는 연결 리스트(linked list)의 형태로 계속 연결되어 파일의 끝까지 이어진다.

![](/imgs/os/os43.png)

구조와 구현이 간단해서 아직도 널리 사용되고 있는 방법이다.

### FAT
연결 파일 방식을 사용하나, 조금 더 최적화된 버전이다. FAT(File Allocation Table)에 링크를 올려놓는 방식으로 이루어지는데, 연결 파일과 같은 방식으로 동작하지만 FAT 전체를 캐시에 올려놓을 수 있어 디스크 접근의 비용을 완화할 수 있다.

![](/imgs/os/os44.png)

이러한 방식은 파일에 append하고, 파일을 삭제하고, 가용 블록을 찾는 걸 쉽게 해준다. 하지만 파일 블록이 점점 흩어진다(scattered)는 단점이 있다.

## Inode
Inode는 파일의 (파일의 이름을 제외하고) 각종 메타데이터를 포함하며, 그에 더해 실제 블록을 가리키는 블록 포인터를 포함하는 특별한 자료구조다. 디렉터리도 파일의 일종이기에, 한 inode는 하나의 파일, 혹은 하나의 디렉터리에 대응될 수 있다. 이러한 inode는 다른 inode를 가리킬 수 있다. 직접적으로 블록을 포인팅하는 경우엔 직접 블록을 참조한다고 하고, 다른 inode를 거쳐 포인팅하는 경우엔 n중 간접 블록을 참조한다고 한다.

![](/imgs/os/os46.png)
