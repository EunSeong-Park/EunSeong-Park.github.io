---
title:  "[OS 3] 동시성과 스레드"
tags: OS
toc: true
---

# Intro
스레드(thread)는 CPU 이용의 기본 단위라 할 수 있다. 우리는 이 스레드 개념을 이용해, 보다 CPU 자원을 효율적으로 활용할 수 있을 것이다. 그러면 이 스레드는 무엇으로 구성되고, 어떻게 활용되며, 여기서 OS는 스레드 관리와 이용을 위해 어떤 역할을 수행할까? 이제부터 알아볼 것이다.


# Thread
한 프로세스 내에는 여러 개의 스레드(thread)가 존재할 수 있고, 이들은 각각 고유한 ID, PC, 레지스터 집합, 스택 등을 가지며, 프로세스 내 같은 스레드끼리 여러 OS 자원을 공유한다. 고전적인 프로세스 및 프로그램은 단일 스레드로 구성되어 있지만, 여러 개의 스레드를 포함하는 멀티 스레드 프로세스 또한 존재한다.

스레드란, separately schedulable task인 single execution의 sequence라고 볼 수 있다. (한국어로 잘 안옮겨진다) 아무튼 여기서, 개별적으로 스케줄링 가능하다는 말이 중요한데, 이는 OS가 특정 스레드를 돌리거나(run) 유예시키는(suspend) 것이 언제든 가능하다는 의미이다.


## Thread vs Process
어찌보면 프로세스랑 비슷한 개념처럼 보이는데 (실제로 Linux는 스레드를 프로세스의 특별한 종류로 본다), 몇 가지 측면에서 중요한 차이점이 있다.

Thread | ? | Process
---|---|---
low | Switch overhead | high
low | Creation of new one | high
yes | CPU protection | yes
no | memory / I/O protection | yes
low | Sharing overhead | high

앞서 말했듯, 동일 프로세스 내 스레드는 몇 가지는 개별적으로 가지며, 힙, 코드, 데이터 섹션, 파일 등 몇 가지는 서로 공유한다. 이 때 다른 스레드로부터 스레드의 일부 정보(특히 스택)는 보호받지 않는다.

![](/imgs/os/os7.png)

## Multithread
멀티 스레드 방식의 프로그램은 여러 면에서 유용하다.

1. Responsiveness : 다중 스레드의 서버 구조를 생각해보자. 클라이언트의 요청을 받으면 서버는 다른 요청을 listen하지 못하고 해당 요청을 처리해야겠지만, 요청을 서비스할 스레드를 생성함으로써 서버는 자신의 응답성을 향상시킬 수 있다.
2. Resource sharing : 프로세스는 일부 자원 공유를 위해 명시적인 방법을 사용해야 하지만, 스레드는 이러한 자원 공유가 자동화 되어있다. 
3. Economy : 위에서 보았듯, 스레드는 프로세스에 비해 각종 작업(스위칭, 생성 등)을 위해 적은 자원을 사용한다.
4. Scalability : 증대된 병렬성으로, (멀티 프로세서를 사용할 때 특히) 작업 처리를 위한 규모 가변성이 증가한다. 

하지만 멀티 스레드 모델이여도 몇 가지 구조적인 한계에 직면할 수 밖에 없다.

### Amdahl's Law
암달의 법칙(Amdahl's law)은 병렬 처리를 통한 성능 향상의 한계를 설명한다. 작업 전체에서 일부는 병렬화할 수 없어, 또는 다른 작업에 의존적인 어떤 작업이 있어 향상 불가능한 부분이 있다는 법칙이다. 즉, 병렬성을 무한정 늘린다고 해서, 그의 역수만큼 처리 시간이 짧아지는 건 절대 아니다.

### Unpredictability
각각의 병렬 작업이 어떤 순서로 끝나는지, 언제 스위칭이 일어날지, 이런 사항을 전부 알 수 있을까? 스레드의 퍼포먼스는 굉장히 예측 불가능해 이를 확인 및 제어하기는 어렵다.


# Thread Programming
다중 코어(멀티 프로세서)를 충분히 활용하려면 소프트웨어 개발 단계에서 이를 고려한 스레드 프로그래밍을 성공적으로 해내야 한다. 위에서 언급한 예측 불가능성은 스레드 프로그래밍을 어렵게 하고, 가능한 경우를 매우 많게 한다. 또, 병렬 작업이 어느 한 쪽으로 쏠리지 않게 균형을 맞추어야 하며, 공유 데이터에 대한 동기화 등 필요로 하는 작업과 고려해야 하는 사항이 많다.

스레드 라이브러리는 프로그래머에게 스레드 생성 및 관리를 위한 API를 제공한다. 종류가 여럿 있지만, 일반적으로 다음과 같은 기능을 지원한다.

- `thread_create(thread, func, args)` : `func(args)`를 작동하기 위한 스레드를 새로 생성한다.
- `thread_yield()` : 프로세서 점유를 자발적으로 놓아준다.
- `thread_join(thread)` : fork된 스레드가 종료되길 기다리고, 이후 리턴한다.
- `thread_exit` 스레드를 종료한다.

## Thread example

스레드 프로그래밍된 예제를 보면 스레드의 동작 원리를 이해하는 데 도움이 될 것이다. 아래 코드를 보자.

    #define NTHREADS 10
    thread_t threads[NTHREADS];
    main() {
      for (i=0; i < NTHREADS; i++)
        thread_create(&threads[i], &go, i);
      for (i=0; i < NTHREADS; i++) {
        exitValue = thread_join(threads[i]);
        printf("Thread %d returned %ld\n", i, exitValue);
      }
      printf("Main thread done.\n");
    }

    void go (int n) {
      printf("hello from thread %d\n", n);
      thread_exit(100 + n);
      // REACHED?
    }

이 프로그램은 스레드 0-9, 10개를 생성하여 `go`함수를 각각의 스레드 번호로 실행되도록 한다. 여기서 우리가 순서를 보장할 수 있는 부분과 그렇지 않은 부분이 있을 것이다.

- `Hello from thread i` 끼리는 순서를 보장하지 않는다. (for loop에 의해 i가 i+1보다 먼저 실행된다고 하더라도)
- `Hello from thread i`는 `Thread i returned 100+i`에 선행된다.
- `Thread i returned 100+i` 끼리는 순서가 보장된다. (앞의 스레드가 리턴되어야 다음 iteration으로 넘어가므로)

## Fork / Join Concurrency
프로세스와 마찬가지로, 스레드도 자신의 자식 스레드를 생성하고, 그것의 종료(completion)을 기다릴 수 있다. 보통, 특정 병렬 작업을 수행하더라도 이후에 master thread를 중심으로 이들을 합치는 과정을 필요로 한다. 예를 들어, matrix multiplication을 수행한다고 할 때, 행 별로, 혹은 열 별로 스레드를 나누어 계산을 하고, 이를 최종적으로 모두 합쳐 더해야 한다. 이 때 joining하는 과정이 반드시 필요하다. 아무튼 그렇게 병합 후, 새로운 병렬 작업이 필요하면 다시 fork, 이후 다시 join하기를 반복한다.

![](/imgs/os/os8.png)

물론, nested한 case도 가능하다.

![](/imgs/os/os9.png)

## Generalizaion into Concurrency Decomposition
결국, 스레드에 의한 병렬적인 작업의 연속은 일종의 digraph로 나타낼 수 있다. 작업들을 도식화함으로써 작업들의 partial ordering과 전반적인 흐름, 의존성들을 확인할 수 있을 것이다. 그러면 지금까지 알아본 내용을 토대로, 어떻게 프로그램을 디자인할까?

- 작업들을 동시적으로 실행할 수 있도록 적절히 나눈다. 
- 효율성의 증대를 위해 어떤 동일한 작업이 존재할 수도 있다.
- 어떤 작업은 독립적이며, 그렇지 않을 수도 있다.
- 이러한 요소들을 도식화하여 순서, 병렬 작업의 밸런스, 의존성 등을 확인한다.

![](/imgs/os/os10.png)


# Thread Scheduling
OS는 컴퓨터 자원을 사용하는 모든 주체가 자원을 적절히(반드시 골고루는 아니다) 할당받을 수 있도록 해야 한다. 이를 위한 과정을 스케줄링(scheduling)이라 한다. 여기서 스레드의 스케줄링을 중점적으로 알아볼 것이다.

스레드 스케줄링엔 크게 두 방식이 있는데, 하나는 선점적(preemptive) 스케줄링, 다른 하나는 비선점적(non-preemptive) 스케줄링이다. 전자는 실행되고 있는 스레드가 선점 당할(be preempted) 수 있음을 의미한다. 즉, 다른 스레드에 의해 점유가 빼앗길 수 있다고 볼 수 있다. 후자는 스레드 스스로가 점유를 넘겨주거나(yield) I/O 등에 의해 블록(block)될 때까지 계속 점유할 수 있음을 의미한다. 일장일단이 있겠지만, 보통의 OS는 선점적 방식이라고 한다.

또한, 대부분의 경우, 유휴 스레드(idle thread)라는 특별한 스레드가 존재하여, 다른 모든 스레드가 스케줄되지 않았을 때 그것이 돌아가게 된다. (즉, 다른 스레드보다 항상 우선권이 적은 것이다.) 이렇게 함으로써, CPU는 활동을 아예 중단했다 다시 켜면서 생기는 부하를 줄이고, 실행 가능한(ready) 스레드가 없는 예외를 발생시키지 않게 된다.


# Kernel Thread & User-Level Thread
스레드 구현 및 관리를 위해 생각해야 할 것이 있다. 바로 커널 스레드(kernel thread)와 사용자 수준 스레드(user-level thread)의 개념이다. "무엇이 스레드를 관리하는가?"에 대한 대답이 될 수 있겠다.

![](/imgs/os/os10.png)

위의 그림은 커널 스레드 모델을 나타낸다. 하나의 커널 스레드가 하나의 사용자 스레드에 대응되어, 모든 스레드가 커널에 의해 관리된다.

커널 스레드 모델은 각각의 스레드가 서로 대응되기 때문에, 병렬성이 좋아 멀티 프로세서에선 효율적으로 동작할 것이다. 또, 커널이 스레드 각각을 관리할 수 있고, 어떤 스레드가 I/O를 수행 중이라면, 다른 스레드를 사용해 다른 작업을 하게 할 수도 있다. 하지만, 커널에 의해 스레드가 관리되기 때문에, 스레드 operation은 커널을 거쳐야 해서 context switching에 많은 오버헤드를 발생시키며, 자원 낭비도 심하다.

![](/imgs/os/os11.png)

위의 그림은 사용자 수준 스레드 모델을 나타낸다. 스레드에 대한 operation은 라이브러리 등에 의해 user-level에서 일어나며, 다수의 스레드가 단 하나의 커널에 대응된다. 이 때, 커널에겐 사용자 스레드가 미지의 영역이 된다.

우선, 사용자 레벨에서 스레드를 조작하기 때문에, context switching이 필요 없다. 하지만, 멀티 프로세서의 이점이 없고, OS에게 사용자 스레드에 대한 정보가 없기 때문에, 어떤 프로세스 내의 스레드가 (I/O 등에 의해) 블록이 걸린다면 나머지 전체 스레드도 함께 블록되며, 스케줄링을 적절한 방식으로 수행하기가 어렵다. (프로세스에게 제공된 우선 순위 하에 내부에서 또 우선 순위를 결정해야 하는 등) 이처럼 OS와의 integration의 부재는 여러 문제를 야기한다.

그렇다면 각각의 단점을 어떻게 보완할 수 있을까? 표현이 적절하지 않은 것 같긴 하지만, 두 모델을 합침으로써 저러한 문제를 어느 정도 해결할 수 있다.

![](/imgs/os/os12.png)

위 그림처럼 여러 개의 사용자 스레드를 그보다 적거나 같은 수의 커널 스레드로 멀티플렉스(multiplex)한다. 이럼으로써 프로그램 개발 단계에서, 필요한 만큼의 사용자 스레드를 생성하며, 그에 대응하는 커널 스레드가 병렬적으로 실행될 수도 있다. 또한, 특정 시스템 콜로 인해 어떤 스레드가 묶이면, 커널이 다른 스레드가 실행되도록 하는 것도 가능하다. 


# Threading Issues
## Thread Pool
보통은 특정 작업을 위해 스레드를 생성하고 이후 버리지만, 미리 생성된 스레드의 집합인 일종의 풀(pool)을 만들어, 거기에 수행할 작업들을 할당할 수도 있다. 이는 스레드 생성/제거를 위한 추가적인 작업을 생략할 수 있도록 하고, 작업이나 시스템, 머신에 따라 능동적으로 스레드 수를 조절할 수 있다. 너무 많은 수의 스레드가 풀에 있으면, 아무 작업도 없이 놀고 있는 스레드가 많아져 메모리 등의 낭비가 발생할 수 있기 때문에, 능동적으로 스레드 수를 조절할 방법을 제공하는 것이다.

## `fork`, `exec` System Calls
다중 스레드 프로그램에서, `fork`로 생성된 프로세스는 모든 스레드를 복제해야 할까? 아니면 호출한 스레드만을 복제해야 할까? `exec`의 경우 기존 스레드는 어떻게 될까?

보통, 어떤 스레드가 `exec`를 호출하면 `exec`가 지정한 프로그램이 모든 스레드를 포함한 전체 프로세스를 대체한다. 그리고, 일부 UNIX 기반의 OS는 모든 스레드를 복제하는 `fork`와 호출한 스레드만을 복제하는 `fork` 모두를 제공한다. 이 경우, 어떤 `fork`를 사용할지는 애플리케이션과 그것의 개발자에게 달려있기 때문에, 상황에 따른 적절한 선택을 해야 한다. 예를 들어, `fork` 이후 child에서 바로 `exec`를 호출한다면, 모든 스레드를 복제하는 건 낭비이자 불필요할 것이다.

## Signal Handling
시그널 핸들링에 대한 전반적인 개념은 CS에서 다루었으니 생략한다. 다중 스레드 프로그램에서의 이슈는, "시그널이 어디로 전달되어야 하는가?" 이다. 다음과 같은 선택지가 있을 것이다. 이는 시그널의 종류에 의존한다.

1. 신호가 적용될 스레드에게 전달한다. (e.g. 0으로 나눈 스레드)
2. 모든 스레드에게 전달한다. (e.g. `Ctrl+C` 등과 같은 asynchronous한 시그널)
3. 일부 스레드에게 선택적으로 전달한다.

대부분의 다중 스레드를 지원하는 UNIX 기반 OS는 스레드가 신호를 받거나 블록할 수 있는 선택권을 준다. 또한, `pthread_kill(tid, signal)`같은 함수처럼 특정 스레드를 지정하여 시그널을 보낼 수도 있다.

## Thread Cancellation
스레드 취소(cancellation)은 스레드가 끝나기 전, 그것을 강제종료 시키는 것을 말한다. 예를 들어, 어떤 데이터를 여러 스레드가 병렬적으로 찾는데, 한 스레드가 데이터를 찾았다면, 나머지 스레드들은 취소되는 게 바람직하다. 또, 어떤 시간이 걸리는 작업에서, 사용자가 (영구)중지 내지는 취소를 한다면, 그 작업을 수행하는 스레드 또한 취소되야 할 것이다.

이러한 스레드의 취소를 위한 두 방법이 있는데,

- 비동기적 취소(Asynchronous Cancellation) : 한 스레드가 타겟 스레드를 즉시 종료시킨다.
- 지연 취소(Deferred Cancellation) : 타겟 스레드가 자신이 취소되어야 하는지를 주기적으로 검사한다.

취소된 스레드는 그 때, 다른 스레드와 데이터를 공유하거나 갱신하고 있었을 수도 있다. 그러한 상황에서 비동기적 취소가 이루어질 때 큰 문제를 야기할 수 있는데, 지연 취소의 경우, 스레드가 자신이 취소되어도 안전하다고 판단될 때 취소 여부를 검사할 수 있다.


# 마치며
굉장히 내용이 많았던 것 같다... 다음엔 CPU 스케줄링이다.



