---
title: "[OS 1] Overview of OS"
tags: OS
toc: true
---

# Intro
**OS**는 컴퓨터 시스템을 구성하는 요소들 중에서 하드웨어랑 가장 가까이 있어, 하드웨어를 제어하며 응용 프로그램 간의 하드웨어 사용을 조정할 수 있다. 달리 말하면, 특정한 작업을 적절하게, 그리고 효율적으로 수행하기 위해 시스템 내의 다양한 자원(메모리, I/O 디바이스, CPU 등)을 적절히 분배, 및 할당한다. 또한, 프로그램을 정상적으로 구동시키고, 그것이 심각한 문제를 발생하지 않도록 적절한 핸들링을 수행하기도 한다. 이러한 맥락에서, OS는 __Resource Allocator__ 면서, 동시에 __Control Program__ 이라고 볼 수 있다. 두 측면 모두 OS의 중요한 특징이자 정체성이다.

아무튼 이러한 OS의 역할을 충분히 수행하고, 컴퓨터의 동작과 사용자와의 원활한 상호작용을 위해선, 사용하기 쉬워야 하고(**convenient**), 효율적이여야 하며(**efficient**), 안전해야 한다(**secure**).

이제부터, 컴퓨터 시스템 아키텍처, 하드웨어, 그리고 OS가 어떤 구조를 가지고 서로 상호작용하는지 알아보고, 앞서 언급한 OS의 목표를 어떠한 방식으로 이루어내는지 살펴볼 것이다. 어차피 오버뷰라 간단히만 훑어볼 예정이다.ㅎ

# Architecture & Paradigms
## Processor
가장 간단한 방법으로, 프로세서에 따라 시스템을 구분할 수 있다. 싱글 프로세서 시스템과 멀티 프로세서 시스템으로!

- **Single-processor system**: 하나의 범용(general-purpose) 단일 프로세서를 시스템. 특정 용도(graphic controller, disk controller)의 프로세서를 함께 가질 수 있지만, 이들은 user process를 돌리지 않는다.
- **Multi-processor system**: parallel system / tightly-couples system으로도 불린다. 다수의 프로세서가 특정 작업을 분담하거나 여러 작업을 함께 수행한다.

오늘날엔 대부분이 멀티 프로세서 시스템을 채택하기 때문에, 이를 조금 더 살펴보도록 하자.

우선 멀티 프로세서 시스템의 장점은 명확하다.

- 처리율(throughput)의 증가
- 규모의 경제 (다수의 싱글 프로세서 시스템과 비교하여)

그리고 이는 다시 두 타입으로 나누어볼 수 있다. 

- **AMP**: Asymmetric MultiProcessing. (흔히 master/slave 구조로 일컫는) 비대칭성 통신 모델을 통해 각각의 프로세서에게 특정한 작업을 할당하는 방식.
- **SMP**: Symmetric MultiProcessing. 모든 프로세서는 동등하고, 어느 작업이든 구동할 수 있도록 하는 방식. System bus에 의해 각 CPU, 메모리, I/O가 연결된다.

![](/imgs/os/os52.png)

## Core
단일 CPU chip에 다수의 코어가 포함되어, 마치 (CPU 수) $\times$ (코어 수)만큼 프로세서가 존재하는 것과 같은 일루전을 줄 수 있다. 프로세서가 physical chip에 의한 logical execution unit이라면, 코어는 L1 cache, 기타 functional unit을 포함하는 logical execution unit이다.

이러한 멀티 코어 환경에서, 코어 배치 방식에 따른 system design choice가 있다.

- **UMA**: Uniform Memory Access.  모든 코어는 모든 메모리 모듈에 대한 동일한 접근 시간을 가진다.
- **NUMA**: Non-Uniform Memory Access. 메모리 모듈에 따라 서로 다른 메모리 접근 시간을 가진다.

![](/imgs/os/os53.png)

## Multi-programming
한 프로그램이 I/O 상호작용을 기다리는 등의 이유로 유의미한 일을 하지 않는데, CPU가 그 프로그램만 하염없이 기다리고 있다면, 이는 엄청난 낭비일 것이다. 하나의 logical execution unit은 둘 이상의 작업을 동시다발적(simulataneous)으로 실행할 수 없기에 더욱 난감하다.

위의 상황이라면, 아마 그 프로그램에게서 CPU를 뺏어다가 다른 (더 CPU를 필요로하는) 프로그램에게 주는 게 최선일 것이다. 이렇게 여러 프로그램들이 동시적(concurrent)으로, 즉, 시간적으로 중첩되어 실행되는 것을 멀티 프로그래밍이라고 한다. 

멀티 프로그래밍의 핵심은 [스케줄링(scheduling)](https://eunseong-park.github.io/2020/02/06/OS-4-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81.html)이다. 즉, 현재 있는 작업 중, 어느 녀석에게 효율적이고 효과적으로 CPU를 줄지를 결정하는 게 중요하다. 이는 이후에 스케줄링 알고리즘을 통해 다시 알아볼 것이다.

그리고 이러한 작업의 전환이 충분히 빠르다면, 다수의 작업을 교대로 수행하면서 마치 모든 작업이 동시에 이루어지는 것과 같은, 그리고 다수의 사용자가 사용하는 시스템에서도 자기 혼자 시스템을 사용하는 것과 같은 일루전을 줄 수 있을 것이다. 이러한 시스템을 시분할(time-sharing) 시스템이라고 한다.

# Roles / Operations of OS
## Operating System Services

![](/imgs/os/os50.png)

OS는 사용자와 프로그램에게 다양한 종류의 서비스를 제공한다. 주요 서비스만 간단히 알아보자.

- **User interface**: CLI, GUI, Batch 등에 의한 유저 인터페이스는 사용자로 하여금 컴퓨터 시스템과 상호작용할 수 있도록 하는 매개체가 된다. 
- **Program execution**: 시스템은 프로그램을 메모리로 불러오고(load) 실행시키며, 종료시킨다. 종료는 정상적일 수도, 비정상적일 수도 있다.
- **I/O operation**: 파일을 포함하여, I/O 디바이스와의 상호작용을 돕는다.
- **File-system manipulation**: 프로그램이 파일과 디렉터리에 대한 다양한 조작을 수행할 수 있도록 한다.
- **Communication**: 프로세스가 다른 프로세스, 혹은 (네트워크를 통하여) 다른 컴퓨터 내의 프로세스와 교류할 수 있도록 한다.
- **Error detection**: OS는 다양한 레벨에서 발생할 수 있는 오류를 감지하고, 그에 대한 적절한 동작을 수행한다.
- **Resource allocation**: 동시적(concurrent)으로 실행되는 여러 작업들에 대하여, 자원을 적절한 방식으로 할당한다.
- **Accounting**: 컴퓨터 리소스 사용(usage)을 추적 및 기록한다.
- **Protection / Security**: 모든 컴퓨터 리소스가 잘 통제되고, 외부(outsider)로부터 적절한 인증(authentication)을 요구할 것을 보장한다.

## Interrupts
**인터럽트(interrupt)**는 프로세서에게 특정 이벤트를 알리는 시그널이라고 볼 수 있다. 인터럽트를 걸면, 시스템은 그에 대한 적절한 대응(handling)을 수행한다. 이는 I/O 이벤트일 수도, 시스템 콜일 수도, 오류 처리일 수도, 프로세스의 제어일 수도 있다.

인터럽트는 하드웨어에 의해서도, 소프트웨어에 의해서도 일어난다. 

- **Trap**: (시스템 콜과 같은) OS 서비스에 대한 SW의 요청 
- **Exception**: (0으로 나누는 등의) SW error

인터럽트가 걸리면 일반적으로 다음과 같은 동작을 수행한다.

1. 현재 명령어(instruction)를 끝낸다.
2. 사용자 프로그램의 (레지스터 정보와 같은) state를 저장한다.
3. 인터럽트를 참고하여 적절한 명령어 위치로 이동한다.
4. 인터럽트 서비스 루틴을 실행한다.
5. 백업한 state를 복원하고 사용자 프로그램을 재시작한다.

## Dual-Mode
OS는 컴퓨터와 시스템을 안전하게 보호할 의무가 있다. 이를 위해 **기본적으로 OS는 사용자를 믿지 않는다.** 사용자와 사용자 프로그램이 다른 프로그램과 시스템을 박살내면 굉장히 곤란해지므로, OS는 이들에게 제한된 권한을 줄 필요가 있다. 그래서 기본적으로 사용자는 HW, 다른 프로세스, 시스템, 커널 등에 대한 전반적인 오퍼레이션을 수행할 수 없다. 하지만 그러한 기능이 반드시 필요할 때가 있다. 간단히 어떤 파일을 여는 것만 해도 그러한 권한이 필요하다.

이러한 맥락에서 나온 게 **듀얼 모드(dual-mode)**다. 제한된 권한을 가진 유저 모드(**user mode**), 모든 권한을 가진 커널 모드(**kernel mode**)로 나누어 명령어를 실행한다. 이게 무슨 도움이 되냐?

- 필요할 때만 권한을 가지고, 그 안에서도 제한되고 적절한 동작을 하기에 안전하다.
- 안전하면서도 사용자는 (요청이 적절하다면) 충분히 서비스를 누릴 수 있다.

듀얼 모드는 하드웨어에 의해 제공되는 **모드 비트(mode bit)**에 의해 관리되며, 시스템 콜 등의 요청으로 인해 커널 모드로 돌아오면, 서비스 후 다시 유저 모드로 돌아간다.

![](/imgs/os/os04.png)

## System Calls
**시스템 콜(system call)**은 OS에 의해 제공되는, OS 서비스를 위한 프로그래밍 인터페이스다. 쉽게 말해, OS한테 "나 이것좀 해줘!"라고 요청하는 셈이다. 이들은 보통 직접적으로 사용 및 호출되진 않고, high-level API를 통해 호출된다. 왜?

- 해당 API를 지원하는 환경 및 프로그램은 시스템 콜을 문제 없이 사용할 수 있다. 즉, 이식성(portability)이 향상된다.
- 직접적인 시스템 콜을 호출하는 것보다 사용하기 쉽다.
- High-level에서의 상호작용은 커널 및 시스템의 보호 및 보안을 돕는다.

![](/imgs/os/os51.png)

API를 통해 시스템 콜을 시도하면, 커널 모드에서 시스템 콜 테이블을 통해 그에 맞는 시스템 콜을 찾아 실행하고, 이후 리턴하여 유저 모드로 돌아가는 방식이다.

## Timer
가령 어떤 프로세스가 무한 루프를 도는 등으로 인해 계속 리소스를 잡아먹고 있다면 어떨까? **타이머(timer)**는 이러한 리소스 낭비를 막아준다. 타이머는 한 틱(tick)마다 OS에 의해 설정된 카운터를 줄이고, 그 카운터가 0이 된다면 인터럽트를 생성해 걸어버린다.

이 때, 정상적으로 실행되는 프로그램이라면 인터럽트 처리 후 제어를 다시 얻겠지만, 제한 시간을 초과한 프로그램이라면 그대로 프로그램을 종료시킨다.

이는 효율적인 자원 운용도 있지만, 결국은 protection 메커니즘의 일종이기도 하다. **OS는 결국은 제어를 돌려받아야 한다** 라는 아이디어에 근거한다.

## Process Management
**프로세스(process)**는 running program의 인스턴스이며, 시스템 위에서 수행되는 작업의 단위이기도 하다. OS는 다양한 측면에서, 다양한 방식으로 프로세스를 관리한다.

- (위에서 언급했듯) 프로세스를 스케줄링한다.
- 사용자 / 시스템 프로세스를 생성 및 제거한다.
- 프로세스를 중지 / 재시작한다.
- 프로세스 간 동기화를 수행한다.
- 프로세스 간 통신을 수행한다.

또, 프로세스에 대한 많은 보호 메커니즘을 제공한다. 듀얼모드나 타이머의 존재도 그렇고, 다른 프로세스가 사용하는 메모리 영역이나 previleged instruction의 실행을 제한하는 것도 그렇다.

나중에 다 살펴볼 것이다. 지금은 오버뷰니까 여기까지!

## Memory Management
**메모리(memory)**도 컴퓨터의 소중한 자원 중 하나여서 잘 관리되어야 한다. 몇 개의 이유가 있는데,

- 용량이 한정적이다. 우리가 필요로 하는 모든 게 메모리에 들어올 수는 없다.
- 메모리에 중요한 정보(어떤 프로세스의 코드나 데이터)가 있을 수 있다.

우리는 적절한 메모리 관리를 위해 isolation, swapping 등 다양한 기법을 사용한다. 이것도 나중에 알아보자.

## Storage Management
OS는 **파일(file)**로 일컬어지는 저장공간의 단위를 적절히 관리한다. 디렉터리로 파일들을 구조화하는 것도, 파일 시스템을 세우고 관리하는 것도 OS의 역할 중 하나다.

# OS Structure
OS는 그 종류와 목적에 따라 서로 다른 구조와 동작 방식을 가진다. 특히 범용 OS는 굉장히 큰 규모를 가진 복잡한 프로그램이다. 

OS는 주로 다음과 같은 구조를 가질 수 있다.

- **Simple structure**
- **More complex structure**
- **Layered structure**
- **Microkernel**
- **Kernel module**
- **Hybrid**

## Simple Structure : MS-DOS
MS-DOS와 같은 간단한 OS는 모듈로 분할되어있지 않고, 적은 공간으로 대부분의 기능을 지원하는 방향으로 설계되었다. 

![](/imgs/os/os54.png)

## More Complex Structure : UNIX
UNIX OS는 두 개의 separable part로 구성된다.

- **System Program**
- **Kernel**

**커널(kernel)**은 시스템 콜 인터페이스와 물리적 하드웨어 사이의 거의 모든 것을 포함하는 것으로, 파일 시스템, 스케줄링, 메모리 관리와 같은 OS function을 제공한다.

![](/imgs/os/os55.png)

## Layered Structure
OS가 다수의 레이어(layer)로 모듈화되어 분할되는 방식이다.

![](/imgs/os/os56.png)

모듈이면 모듈이지, 왜 레이어 형태를 가지느냐?라는 의문이 들 수 있다. Layered 모델의 중요한 성질 중 하나는 계층(hierarchy) 구조다. Higher layer는 그 아래의 레이어에 직접적으로 접근하거나 조작할 수 없다. 대신, 필요한 경우 낮은 계층의 레이어는 높은 계층을 위한 인터페이스를 제공함으로써 자신의 기능을 사용할 수 있도록 해준다.

이러한 방식은 낮은 계층의 레이어를 보호함과 동시에 모듈러리티도 보장해준다.

## Microkernel System Structure
Mach 등과 같은 **마이크로커널(microkernel)** 구조는 기존 구조에서 커널의 (상당 부분의) 일부를 다른 곳으로 전가해, 커널 자체의 규모를 줄인 형태다. 가령 시스템 콜, 디바이스 관리, 파일 시스템 등을 유저 모드로 넘길 수 있다.

이러한 방식은 안정성, 확장성, 이식성을 좋게 한다. 하지만 유저-커널 간 통신에 의한 오버헤드가 커진다는 단점도 존재한다.

![](/imgs/os/os57.png)

## Modules
현대 OS는 **loadable kernel module**을 채택하여 구현한다. 객체 지향적인 approach를 따라, 각각의 컴포넌트가 분리 가능하고, 커널에서 필요할 때 로드하는 등, 레이어와 비슷하지만 조금 더 유연하다는 특징을 가진다. Linux, Solaris 등이 대표적인 예시다.

![](/imgs/os/os58.png)

## Hybrid Systems
사실 오늘날의 OS는 순수하게 하나의 모델을 채택해 구현된 경우가 드물다. 모델들을 적당히 결합해 장점을 최대한 살리고, 단점을 최대한 보완하는, hybrid 방식을 사용한다.

![](/imgs/os/os59.png)

위 사진은 Mac OS X의 구조다. 전반적으로 layered한 느낌을 주는데, Mach 마이크로커널을 포함하며, 동적으로 로드할 수 있는 kernel extension들도 포함한다. 말 그대로 짬뽕인 셈이다.


# 마치며
지금까지 OS에 관해 매우 넓게 오버뷰를 해보았다. 이제부터 하나하나 알아가도록 하자. 


<!--

## Interaction with I/O Device
### Interrupt
I/O 디바이스를 통해 시스템은 외부 장치와 상호작용 할 수 있다. 각각의 디바이스는 그에 해당하는 컨트롤러에 의해 관리되며, 디바이스 컨트롤러는 장치를 드나드는 데이터를 임시로 저장할 로컬 버퍼(local buffer)를 가져, CPU가 메인 메모리와 로컬 버퍼 사이에서 데이터를 전송한다. 이 때, CPU와 I/O 디바이스는 동시에(concurrently) 돌아갈 수 있다. 이 conccurrency가 꽤 중요한 특징인데, memory hierarchy를 통해 알 수 있듯이, CPU는 굉장히 중요하고 귀중한 자원이다. 특정 작업에 불필요하게 낭비된다면 시스템과 사용자 모두에게 크나큰 손해일 것이다. 

어떤 프로그램이 시스템 콜로 표준 입력을 받는다고 가정하자. 커널은 입력이 완료될 때까지 아무것도 하지 않고 기다려야 하는가? 그러한 busy-waiting(polling)은 귀중한 CPU 자원의 막대한 손실을 초래할 것이다. 여기서 OS는 인터럽트(interrupt)의 도입으로 이러한 작업을 효율적으로 돌릴 수 있다.

이러한 상황에서, 디바이스 컨트롤러는 장치로부터 자신의 로컬 버퍼로 데이터를 가져온다. 데이터 수신이 완료되면 인터럽트를 걸어 입력이 완료되었음을 알리고, OS에게 제어(control)를 넘기고 그에 대한 적절한 작업을 수행한다. 이로써 CPU는 들어올 데이터를 하염없이 기다릴 필요가 없고, 입력이 완료되었을 때만 자신의 자원을 사용한다.

![](/imgs/csapp/107.png)

interrupt의 핸들링 방식은 CS에서 다루었으므로 설명을 생략한다.

### Data Transfer Modes
CS에서도 짚었던 내용이지만, I/O에서 데이터를 전송하는 방법에 대해 잠깐 알아보고 가자.

데이터 전송에는 두 가지 방법이 있다. Programmed I/O(PIO)와 Direct Memory Access(DMA)가 있는데,

- PIO : CPU가 I/O 디바이스와 메모리 사이의 데이터 전송에 관여(involve)한다.
- DMA : I/O 디바이스와 메모리가 CPU를 거치지 않고 데이터를 송수신한다.

PIO는 큰 용량의 데이터를 전송할 때 높은 오버헤드(overhead)가 발생하는 등의 문제점이 있어 DMA가 고안되었다. 데이터 블록의 전송이 완료될 때마다만 인터럽트가 발생하기 때문에 CPU는 그동안 다른 작업을 열심히 수행할 수 있다.

![](/imgs/csapp/108.png)

딱히 OS와 큰 직접적인 연관이 없어보이는 이걸 갑자기 왜 언급하냐 하면, 그냥 책이랑 ppt에 나왔길래 별 생각 없이 썼다... 많이 알면 좋지 뭐

## Process Management
프로세스(process)는 프로그램의 인스턴스(instance)이자 제한된 권한(privilege) 하에서 프로그램을 실행시키기 위한 OS의 추상화(abstraction)기도 하다. 이 제한된 권한이 프로세스 관리에서의 key-point다. 이로 인해 OS는 신뢰할 수 없는 응용 프로그램으로부터 시스템과 하드웨어를 지킬 수 있다. 이를 위한 기능들을 몇 개 알아보자.



여기서 1, 2번을 조금 더 자세히 알아보려고 한다.

### Dual-Mode Operation
말만 조금 달라졌을 뿐, CS에서 배운 그대로다. 커널 모드(kernel mode)는 하드웨어에 대한 모든 권한을 가지고 있으며, 어느 메모리든, 어느 I/O 디바이스든, 어느 디스크 섹터든, 어느 패킷이든 접근, r/w 및 송수신을 수행할 수 있다. 그리고 사용자 모드(user mode)는 제한된 권한을 가져, CPU가 모든 인스트럭션을 실행 전 체크한다.

### Privileged Instructions & System Call
중요하거나 치명적일 수 있는 인스트럭션엔 무엇이 있을까? 그리고 이런 인스트럭션을 만나면 어떻게 처리할까?

Privileged instruction엔 다음과 같은 것들이 있다.

- 모드나 시스템 구동에서의 중요한 정보를 저장하는 `EFLAGS` 레지스터의 모드 비트를 변경한다.
- I/O 디바이스에 명령을 전달하거나, 이로부터 데이터를 읽는다.
- 커널 코드로 점프한다.

이러한 명령을 사용자 프로그램에서 실행시킬 수 없는 건, 시스템은 사용자 프로그램을 전혀 신뢰하지 않기 때문이다. 반면 OS는 완전히 신뢰할 수 있게 만들어져있고, 그렇게 만들어져야 하므로 OS에게만 이러한 명령을 실행할 수 있는 권한을 부여한다. 만약 사용자 프로그램이 이러한 명령을 시도하면, CPU는 OS에게 시그널을 전송하여 처리한다.

하지만 사용자 프로그램에서 이러한 명령을 필요로 할 때가 분명히 존재한다. 시스템 입출력이 가장 대표적인 예시일텐데, 이럴 때 프로그램은 커널에게 그러한 명령을 수행할 것을 요청하며, 그것이 허가될 때는 커널이 프로그램을 대신하여 명령을 수행한다. 이러한 과정은 시스템 콜(system call)에 의해 구현되어 있는데, 시스템 콜을 통해 모드 전환(mode switch)이 일어나 권한을 잠시 얻을 수 있다. 

하지만 시스템 콜 또한 고급 언어에선 대개는 직접 호출되지 않으며, high-level의 API(Application Program Interface)에 의해 간접적으로 호출된다. C에서 `write`를 호출하는 라이브러리 함수인 `printf`를 호출하는 것과 같은 맥락이다. 

## Memory Protection

![](/imgs/csapp/109.png)

각각의 프로세스는 자신만을 위한 메모리가 할당된다. 그리고 타 메모리로의 접근을 막기 위해서, 즉 메모리 보호를 위해서는 각각의 프로세스는 자신에게 할당된 메모리로만 접근을 해야한다. 이러한 제한 및 보호는 `base`와 `limit`(혹은 `bound`)라 불리는 두 레지스터에 의해 이루어지는데, `base`는 허용된 메모리 주소의 시작점을, 그리고 `limit`은 허용된 메모리 주소 공간의 길이를 나타낸다. 예를 들어, `base`가 `0x10000`이고, `limit`이 `0x01000`이라면, 해당 프로세스는 `0x10000`부터 `0x11000`까지의 접근이 허용되는 셈이다. 만약 이 범위를 벗어나면 예외(exception)를 발생시킨다.

+) 여기서 흥미로운 문제를 강의 때 들었다.
Q. 두 프로세스는 `0x30000`크기의 VA를 가지는데, 가능한 케이스는?

- P1: `0x00000 - 0x30000`, P2: `0x30001-0x60001`
- P1: `0x00000 - 0x30000`, P2: `0x00000-0x30000`
- P1: `0x00000 - 0x30000`, P2: `0x10000-0x40000`

답은 __세 경우 모두 가능하다__ 였다. 두 번째 케이스만 가능할 줄 알았는데 의외였다.

## Timer Interrupt
응용 프로그램은 주기적으로 CPU 제어를 OS에게 넘긴다. 이는 프로그램이 여러 이유(무한 루프 등)로 제어가 OS로 넘어가지 않는 걸 방지하기 위해서다. 

CPU는 주기적으로 커널에게 인터럽트를 건다. 이 때 프로세스는 멈추며, 인터럽트에 대한 커널 코드(즉, 핸들러)가 실행된다. 이 때 문제가 없을 경우, 즉, 타이머가 인터럽트를 할 수 있고, 프로세스에 할당된 제한 시간이 초과되지 않고, 그 외의 다른 특수한 상황이 발생하지 않은 경우, 제어를 다시 프로세스에게 넘겨준다.


지금까지 OS가 시스템을 어떻게 안전하고 효율적이게 만드는지 매우 짧게 알아보았다. 이제 잠깐 mode switch에 대해 조금 더 자세히 알아보려고 한다.

## Mode Switch
Dual-mode기 때문에, mode switch는 kernel-to-user, 그리고 user-to-kernel 모두 일어날 수 있다. 

User-to-kernel : 인터럽트, 예외, 시스템 콜 등에 의해 일어난다.
Kernel-to-user : 새 프로세스/스레드가 시작할 때, 인터럽트/예외 핸들러나 시스템 콜의 리턴, context switch 이후 등에서 일어난다.

이제 mode switch가 어떻게 이루어지는지 간단히 알아보자.

모든 하드웨어는 IRQ(Interrupt ReQuest)에 할당되어, 각각 0-255 사이의 IRQ 넘버를 가진다. CPU는 매 인스트럭션 수행 후 IRQ 라인을 검사해, 어떤 하드웨어가 이곳에 신호를 보냈다면, 이를 알아채 각종 정보(레지스터, 상태 정보 등)를 저장하고 인터럽트 핸들러 루틴으로 점프하며, 핸들러는 그에 대한 적절한 행동을 수행하고 다시 리턴한다. (여기서, '그에 대한 적절한 행동'이라는 건 이벤트 종류에 따른 핸들러를 의미한다.) 이러한 핸들러는 interrupt vector table이라는, OS에 의해 설정된 (일부는 mask 가능하다) 특별한 테이블에 저장되며, 이벤트 종류에 따라 IRQ가 vector의 offset을 결정해 그에 따른 핸들러를 호출한다.

그리고 프로세서마다 인터럽트 스택(interrupt stack)이라는 특별한 스택이 커널 메모리 내에 저장되는데, 인터럽트에 대한 정보 및 각종 레지스터의 값들을 이곳으로 복사한다. 인터럽트 발생 시 context를 스택에 저장한다는 게 이걸 의미했던 것 같다. 핸들러가 처리를 완료하면 이 스택 데이터를 기반으로 원래의 데이터들을 복구하고 유저 모드로 돌아갈 것이다.

-->