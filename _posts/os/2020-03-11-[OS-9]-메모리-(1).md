---
title:  "[OS 9] Memory 1"
tags: OS
toc: true
---


# Intro
우리가 지금까지 스레드, 동기화 등 갖가지 개념을 배온 것은, 다중 프로그래밍(multiprogramming)을 구현하기 위함이다. 각 프로그램이 혼자 메모리 주소공간을 독점하는 듯한 착각을 받을 수 있도록, 각각을 위한 독립적인 공간을 할당하면서도 외부로부터 의도치 않은 공간의 침범을 받지 않도록(침범하지도 않고) 하는 방법이 필요한데, 그것이 바로 **가상 메모리(virtual memory)**다.


# Virtual Memory Overview
간단히 말해, VM은 **프로세스 전체가 실제 메모리(PM)에 올라오지 않아도 실행이 가능할 수 있도록 하는 메모리 관리 기법**이다. VM으로 인해, 우리는 실행시킬 프로그램이 주어진 PM보다 크기가 커도 그것을 실행시킬 수 있다. 그것 외에도, 다른 프로세스로부터 자신이 사용하는 메모리 영역을 보호할 수 있다는 점도 VM의 주 역할 중 하나다. 다른 프로세스의 메모리 침범은 예상치 못한 결과를 낳을 수 있고, (VM이 없다면) 프로그램 수준에서 이를 방지해야하기 때문에 개발을 더욱 어렵게 한다.

![](/imgs/os/os24.png)

여기서 MMU(Memory Management Unit)는 VA와 PA 사이의 매핑(mapping) 및 주어진 주소의 유효성을 검사하는 역할을 수행한다. 유효하지 않은 주소 접근(다른 프로세스의 (공유되지 않는) 영역 또는 커널 영역 등)을 제한함으로써 메모리 보호와 각 프로세스의 메모리 영역에 대한 transparency를 보장해준다. 

그럼 VM은 어떤 방향으로 구현되어야 할까? 잘 만들어진 VM은 다음과 같은 특징을 가질 것이다.

- **Memory protection** : 다른 프로세스에게 할당된 PM 영역에 접근할 수 없도록 제한한다.
- **Transparency** : 프로세스가 PM이 다른 프로세스에게 공유된다는 사실을 알 수 없도록 한다. 즉, 프로그램의 실행이나 개발 과정에서 그러한 사실을 고려할 필요가 없도록 한다. (private address space)
- **Efficiency** : 메모리 배치, 주소 변환 등 VM이 수반하는 과정은 효율적이고 적은 비용으로 이루어져야 한다.


# Relocation
Private address space를 가정하고 프로그램이 작성되었을 것이기 때문에, 실제로 프로그램을 실행시키기 위해선 PM에 맞추어 메모리 참조들이 가리키는 영역에 대한 수정을 해주어야 한다. 예를 들어, `0x200`을 참조하는 명령어를 포함하는 `.text`영역이 PM의 `0x1000`부터 시작한다면 명령어의 주소는 `0x1200`으로 바뀌어야 할 것이다.

![](/imgs/os/os25.png)

그런데, 이러한 과정을 어디서 어떻게 수행할 수 있을까?

## Static Relocation
**Static relocation**은 SW-based한 relocation으로, OS가 로딩 전에 각각의 프로그램을 rewrite한다. HW의 서포트가 필요 없다는 사실은 분명 장점이지만, 이미 적재된 영역들은 이후에 재배치가 불가능하며 (invalid한 주소의 처리가 어려우므로) 상대적으로 낮은 수준의 메모리 보호를 제공한다. 특히 전자의 단점은 여러모로 치명적인데, 프로세스의 생성/제거, 또는 메모리 파편화(fragmentation)같은 상황에 대처하기 어렵기 때문이다.

## Dynamic Relocation
**Dynamic relocation**은 HW-based한 relocation이다. MMU가 모든 메모리 참조에 사용된 주소를 변환(translation)하는데, OS로부터 valid한 주소 공간에 대한 정보를 미리 받아 invalid한 VA를 걸러낼 수 있고, 메모리를 효율적으로 사용할 여러 방법들을 제공한다.

### Partition
**Partition**은 PM을 적절한 크기로 분할해서 사용하는 것을 의미한다. Partition을 통해 우리는 명령어 내의 VA를 rewriting할 필요가 없다. 고정 크기의 파티션과 가변 크기의 파티션, 두 방법으로 나눠볼 수 있는데, 각각의 방법이 어떻게 동작하는지 알아보도록 하자.

#### Fixed Partition
Base 레지스터를 하나 사용해, 나누어진 파티션의 시작 PA를 가리키도록 한다. 이후 VA + Base를 통해 PA를 할당한다. 예를 들어, VA가 `0x0362`, Base가 `0x2000`이라면, PA는 `0x2362`를 가리키게 된다.

![](/imgs/os/os26.png)

Base register를 필요로하기 때문에 fixed partition은 HW-supported method다. Base register는 컨텍스트 전환 시 OS에 의해 로드된다. 이러한 방법은 컨텍스트 전환이 빠르고 구현이 상대적으로 쉽지만, 고정 크기의 파티션으로 인해 internal fragmentation이 발생할 수 있고, 실제 프로세스의 크기와 잘 맞지 않을 수 있다. (큰 쪽으로든 작은 쪽으로든)

우리는 이 구조를 바꾸지 않으면서도 어느 정도 개선할 수 있는데, 파티션 사이즈를 균일하지 않게 하거나, 가장 크기가 잘 맞는 파티션에 할당하는 알고리즘을 도입하는 등을 시도해볼 수 있다.

#### Variable Partition
단어 그대로 파티션의 크기를 가변적으로 정할 수 있다. Base register에 더해, limit 레지스터를 도입해 해당 파티션의 크기를 지정한다. 만약 주소 접근 시 VA가 `limit`을 초과하면 invalid한 접근으로 보아 protection fault를 건다.

![](/imgs/os/os27.png)

Fixed partition에 비해 더 유연한 프로세스 할당이 가능하게 되고, internal fragmentation을 방지할 수 있다. 하지만 연속적이지 않으면 external fragmentation이 발생할 수 있고, 다른 프로세스와 데이터나 코드를 공유할 수 없다는 단점이 있다.

### Segmentation
**세그먼트(segment)**란 VM의 contiguous한 영역을 의미한다. GCC가 만드는 코드(`.text`), 데이터(`.data`), 스택 등의 세그먼트 말하는 거 맞다. 각각의 프로세스는 세그먼트 테이블(segment table)을 (HW 내에서) 가지고 있어, 각각의 엔트리가 세그먼트에 대응된다. 그리고 각각의 세그먼트는 PM 내의 어느 곳에나 위치할 수 있고 start, length, access permission에 대한 정보를 가지고 있어 이를 이용해 접근할 수 있다. 또, segmentation을 통해 프로세스들은 세그먼트들을 효과적으로 공유할 수 있다. 같은 start, length를 가지면 되기 때문이다. (접근 권한은 달라도 상관 없다. reader/writer가 분리될 수도 있으니)

![](/imgs/os/os28.png)

프로세스가 각 세그먼트를 참조하려 할 때, 세그먼트 테이블을 확인하여 범위, 권한이 적절한지 확인한 다음 변환한다. 만약 부적절한 접근일 경우 exception을 발생시킬 것이다.

예전에 배웠듯이, UNIX에서의 `fork`는 현재 프로세스와 완전히 같은(pid 빼고) 복사본을 생성한다. Segmentation의 개념은 이 때의 복사를 효율적으로 수행할 수 있게 도울 수 있다. 왜냐? read-only 영역은 굳이 같은 복사본을 따로 만들 필요가 없고, 쓰기가 가능한 영역도 쓰기를 수행하는 영역에 대해서만 복사본을 만들면 되기 때문이다. 완전히 복붙하는 것보다 공간을 많이 절약할 수 있다. 이러한 방식을 copy-on-write라고 한다.

이처럼 segmentation은 일부 세그먼트의 공유를 가능케 해주고, 세그먼트에 대한 보호도 잘 이루어진다. Copy-on-write가 가능한 점도 장점 중 하나다. 하지만 앞에서의 방법보다 훨씬 복잡한 메모리 관리 방식을 필요로 하고, 여전히 (external) fragmentation으로부터 자유로울 수 없기 때문에 주기적인 재배치가 필요하다.

다음은 페이징(paging)에 대해 알아볼 예정인데, 여기선 너무 길어질 것 같고, 다음 포스트에 쓰기로 한다.
