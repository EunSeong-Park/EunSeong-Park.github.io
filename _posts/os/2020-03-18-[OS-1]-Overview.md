---
tags: [OS 1] Overview
toc: true
---

# Intro
책의 첫 챕터다. 컴퓨터 시스템을 공부할 땐 카네기 멜론에서 가져왔는데, 이번엔 무엇을 자료로 써야할지 참 난감하다. 아무튼 이번엔 OS의 역할과 구조 등에 대해 간단히 알아보려고 한다. 여기 언급되는 대부분의 내용은 다 나중에 자세히 다룰 예정이므로 가볍게 겉핥기만 하고 간다고 생각하자.


# Roles & properties of OS
OS는 컴퓨터 시스템을 구성하는 요소들 중에서 하드웨어랑 가장 가까이 있어, 하드웨어를 제어하며 응용 프로그램 간의 하드웨어 사용을 조정할 수 있다. 달리 말하면, 특정한 작업을 적절하게, 그리고 효율적으로 수행하기 위해 시스템 내의 다양한 자원(메모리, I/O 디바이스, CPU 등)을 적절히 분배, 및 할당한다.

이는 굉장히 뭉뚱그려 설명한 OS의 기능이고, 이젠 OS가 사용자(user)와 하드웨어, 그리고 응용 프로그램 등에게 어떤 이점을 제공하고, 그러한 OS가 되려면 어떠한 특징을 가져야 하는지 알아보자.

결론부터 말하자면, 사용하기 쉬워야 하고(easy to use), 효율적이여야 하며(efficient), 안전해야 한다(secure). 그렇다면, 이러한 OS는 어떠한 방식으로 그 특징을 어떻게 만족시킬까?

## Interaction with I/O Device
### Interrupt
I/O 디바이스를 통해 시스템은 외부 장치와 상호작용 할 수 있다. 각각의 디바이스는 그에 해당하는 컨트롤러에 의해 관리되며, 디바이스 컨트롤러는 장치를 드나드는 데이터를 임시로 저장할 로컬 버퍼(local buffer)를 가져, CPU가 메인 메모리와 로컬 버퍼 사이에서 데이터를 전송한다. 이 때, CPU와 I/O 디바이스는 동시에(concurrently) 돌아갈 수 있다. 이 conccurrency가 꽤 중요한 특징인데, memory hierarchy를 통해 알 수 있듯이, CPU는 굉장히 중요하고 귀중한 자원이다. 특정 작업에 불필요하게 낭비된다면 시스템과 사용자 모두에게 크나큰 손해일 것이다. 

어떤 프로그램이 시스템 콜로 표준 입력을 받는다고 가정하자. 커널은 입력이 완료될 때까지 아무것도 하지 않고 기다려야 하는가? 그러한 busy-waiting(polling)은 귀중한 CPU 자원의 막대한 손실을 초래할 것이다. 여기서 OS는 인터럽트(interrupt)의 도입으로 이러한 작업을 효율적으로 돌릴 수 있다.

이러한 상황에서, 디바이스 컨트롤러는 장치로부터 자신의 로컬 버퍼로 데이터를 가져온다. 데이터 수신이 완료되면 인터럽트를 걸어 입력이 완료되었음을 알리고, OS에게 제어(control)를 넘기고 그에 대한 적절한 작업을 수행한다. 이로써 CPU는 들어올 데이터를 하염없이 기다릴 필요가 없고, 입력이 완료되었을 때만 자신의 자원을 사용한다.

![](/imgs/csapp/107.png)

interrupt의 핸들링 방식은 CS에서 다루었으므로 설명을 생략한다.

### Data Transfer Modes
CS에서도 짚었던 내용이지만, I/O에서 데이터를 전송하는 방법에 대해 잠깐 알아보고 가자.

데이터 전송에는 두 가지 방법이 있다. Programmed I/O(PIO)와 Direct Memory Access(DMA)가 있는데,

- PIO : CPU가 I/O 디바이스와 메모리 사이의 데이터 전송에 관여(involve)한다.
- DMA : I/O 디바이스와 메모리가 CPU를 거치지 않고 데이터를 송수신한다.

PIO는 큰 용량의 데이터를 전송할 때 높은 오버헤드(overhead)가 발생하는 등의 문제점이 있어 DMA가 고안되었다. 데이터 블록의 전송이 완료될 때마다만 인터럽트가 발생하기 때문에 CPU는 그동안 다른 작업을 열심히 수행할 수 있다.

![](/imgs/csapp/108.png)

딱히 OS와 큰 직접적인 연관이 없어보이는 이걸 갑자기 왜 언급하냐 하면, 그냥 책이랑 ppt에 나왔길래 별 생각 없이 썼다... 많이 알면 좋지 뭐

## Process Management
프로세스(process)는 프로그램의 인스턴스(instance)이자 제한된 권한(privilege) 하에서 프로그램을 실행시키기 위한 OS의 추상화(abstraction)기도 하다. 이 제한된 권한이 프로세스 관리에서의 key-point다. 이로 인해 OS는 신뢰할 수 없는 응용 프로그램으로부터 시스템과 하드웨어를 지킬 수 있다. 이를 위한 기능들을 몇 개 알아보자.

1. Dual-mode operation과 mode switch로 하드웨어를 보호한다.
2. 중요하거나 치명적일 수 있는 인스트럭션의 사용을 제한한다.
3. 다른 프로그램의 메모리에 대한 r/w 작업을 제한한다.
4. 타이머 인터럽트를 통해 모든 프로그램이 결국은 제어를 OS를 넘기도록 보장한다.

여기서 1, 2번을 조금 더 자세히 알아보려고 한다.

### Dual-Mode Operation
말만 조금 달라졌을 뿐, CS에서 배운 그대로다. 커널 모드(kernel mode)는 하드웨어에 대한 모든 권한을 가지고 있으며, 어느 메모리든, 어느 I/O 디바이스든, 어느 디스크 섹터든, 어느 패킷이든 접근, r/w 및 송수신을 수행할 수 있다. 그리고 사용자 모드(user mode)는 제한된 권한을 가져, CPU가 모든 인스트럭션을 실행 전 체크한다.

### Privileged Instructions & System Call
중요하거나 치명적일 수 있는 인스트럭션엔 무엇이 있을까? 그리고 이런 인스트럭션을 만나면 어떻게 처리할까?

Privileged instruction엔 다음과 같은 것들이 있다.

- 모드나 시스템 구동에서의 중요한 정보를 저장하는 `EFLAGS` 레지스터의 모드 비트를 변경한다.
- I/O 디바이스에 명령을 전달하거나, 이로부터 데이터를 읽는다.
- 커널 코드로 점프한다.

이러한 명령을 사용자 프로그램에서 실행시킬 수 없는 건, 시스템은 사용자 프로그램을 전혀 신뢰하지 않기 때문이다. 반면 OS는 완전히 신뢰할 수 있게 만들어져있고, 그렇게 만들어져야 하므로 OS에게만 이러한 명령을 실행할 수 있는 권한을 부여한다. 만약 사용자 프로그램이 이러한 명령을 시도하면, CPU는 OS에게 시그널을 전송하여 처리한다.

하지만 사용자 프로그램에서 이러한 명령을 필요로 할 때가 분명히 존재한다. 시스템 입출력이 가장 대표적인 예시일텐데, 이럴 때 프로그램은 커널에게 그러한 명령을 수행할 것을 요청하며, 그것이 허가될 때는 커널이 프로그램을 대신하여 명령을 수행한다. 이러한 과정은 시스템 콜(system call)에 의해 구현되어 있는데, 시스템 콜을 통해 모드 전환(mode switch)이 일어나 권한을 잠시 얻을 수 있다. 

하지만 시스템 콜 또한 고급 언어에선 대개는 직접 호출되지 않으며, high-level의 API(Application Program Interface)에 의해 간접적으로 호출된다. C에서 `write`를 호출하는 라이브러리 함수인 `printf`를 호출하는 것과 같은 맥락이다. 

## Memory Protection

![](/imgs/csapp/109.png)

각각의 프로세스는 자신만을 위한 메모리가 할당된다. 그리고 타 메모리로의 접근을 막기 위해서, 즉 메모리 보호를 위해서는 각각의 프로세스는 자신에게 할당된 메모리로만 접근을 해야한다. 이러한 제한 및 보호는 `base`와 `limit`(혹은 `bound`)라 불리는 두 레지스터에 의해 이루어지는데, `base`는 허용된 메모리 주소의 시작점을, 그리고 `limit`은 허용된 메모리 주소 공간의 길이를 나타낸다. 예를 들어, `base`가 `0x10000`이고, `limit`이 `0x01000`이라면, 해당 프로세스는 `0x10000`부터 `0x11000`까지의 접근이 허용되는 셈이다. 만약 이 범위를 벗어나면 예외(exception)를 발생시킨다.

+) 여기서 흥미로운 문제를 강의 때 들었다.
Q. 두 프로세스는 `0x30000`크기의 VA를 가지는데, 가능한 케이스는?

- P1: `0x00000 - 0x30000`, P2: `0x30001-0x60001`
- P1: `0x00000 - 0x30000`, P2: `0x00000-0x30000`
- P1: `0x00000 - 0x30000`, P2: `0x10000-0x40000`

답은 __세 경우 모두 가능하다__ 였다. 두 번째 케이스만 가능할 줄 알았는데 의외였다.

## Timer Interrupt
응용 프로그램은 주기적으로 CPU 제어를 OS에게 넘긴다. 이는 프로그램이 여러 이유(무한 루프 등)로 제어가 OS로 넘어가지 않는 걸 방지하기 위해서다. 

CPU는 주기적으로 커널에게 인터럽트를 건다. 이 때 프로세스는 멈추며, 인터럽트에 대한 커널 코드(즉, 핸들러)가 실행된다. 이 때 문제가 없을 경우, 즉, 타이머가 인터럽트를 할 수 있고, 프로세스에 할당된 제한 시간이 초과되지 않고, 그 외의 다른 특수한 상황이 발생하지 않은 경우, 제어를 다시 프로세스에게 넘겨준다.


지금까지 OS가 시스템을 어떻게 안전하고 효율적이게 만드는지 매우 짧게 알아보았다. 이제 잠깐 mode switch에 대해 조금 더 자세히 알아보려고 한다.

# Mode Switch
Dual-mode기 때문에, mode switch는 kernel-to-user, 그리고 user-to-kernel 모두 일어날 수 있다. 

User-to-kernel : 인터럽트, 예외, 시스템 콜 등에 의해 일어난다.
Kernel-to-user : 새 프로세스/스레드가 시작할 때, 인터럽트/예외 핸들러나 시스템 콜의 리턴, context switch 이후 등에서 일어난다.

이제 mode switch가 어떻게 이루어지는지 간단히 알아보자.

모든 하드웨어는 IRQ(Interrupt ReQuest)에 할당되어, 각각 0~255 사이의 IRQ 넘버를 가진다. CPU는 매 인스트럭션 수행 후 IRQ 라인을 검사해, 어떤 하드웨어가 이곳에 신호를 보냈다면, 이를 알아채 각종 정보(레지스터, 상태 정보 등)를 저장하고 인터럽트 핸들러 루틴으로 점프하며, 핸들러는 그에 대한 적절한 행동을 수행하고 다시 리턴한다. (여기서, '그에 대한 적절한 행동'이라는 건 이벤트 종류에 따른 핸들러를 의미한다.) 이러한 핸들러는 interrupt vector table이라는, OS에 의해 설정된 (일부는 mask 가능하다) 특별한 테이블에 저장되며, 이벤트 종류에 따라 IRQ가 vector의 offset을 결정해 그에 따른 핸들러를 호출한다.

그리고 프로세서마다 인터럽트 스택(interrupt stack)이라는 특별한 스택이 커널 메모리 내에 저장되는데, 인터럽트에 대한 정보 및 각종 레지스터의 값들을 이곳으로 복사한다. 인터럽트 발생 시 context를 스택에 저장한다는 게 이걸 의미했던 것 같다. 핸들러가 처리를 완료하면 이 스택 데이터를 기반으로 원래의 데이터들을 복구하고 유저 모드로 돌아갈 것이다.


# 마치며
OS의 기능과 역할을 간단히 알아보았다. 대충 서론인 셈인데, 그래서 그런지 굉장히 난잡하게 쓴 것 같다. 퀄리티도 문제지만 쓰는 시간도 문제인데, 다음 주부턴 본격적으로 pintOS도 시작하고, 이번 학기 수업 자체가 좀 많아서 시간 분배를 잘 해야겠다. 아무튼 다음은 프로세스에 대해 논의할 예정이다.




