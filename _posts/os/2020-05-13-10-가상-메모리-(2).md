---
title:  "10 가상 메모리 (2)"
tags: OS
toc: true
---

# Intro
지금까지 가상 메모리(VM)에 대한 기본적인 개념과, 프로세스의 PM으로의 할당을, 그리고 프로그램 내에 포함된 VA 접근을 어떻게 PA에 잘 대응시킬지에 대한 방법, 즉 relocation을 알아보았다. 그래서 SW-based한 rewriting과 partition, 그리고 segmentation에 대해 지난 포스트에서 짚어보았는데, 이번엔 페이징(paging)에 대해 알아보도록 하자.


# Paging
페이징(paging)은 VM을 관리하기 위한 방법 중 가장 보편적이다. 페이징을 통해 우리는 어떤 프로세스가 가지는 PAS를 non-contiguous하게 할당할 수 있게 된다. VM을 고정된 사이즈의 가상 페이지(virtual page)로, PM을 고정된 사이즈의 페이지 프레임(page frame)으로 분할한다. 이러한 분할은 OS가 쉽게 free한 frame을 찾을 수 있도록 돕고, 무엇보다도 non-contiguous한 할당이 가능하기 때문에 메모리 관리가 더욱 용이하다. 또, 고정 사이즈로 분할되므로 external fragmentation이 발생하지 않는다. 

이제 페이징이 어떤 방식으로 동작하는지 알아보자. 앞서 언급했듯, VM은 다수의 페이지로, PM은 다수의 프레임으로 분할한다. 또, 페이지와 프레임 사이의 매핑(mapping)을 위한 페이지 테이블(page table)이 VM과 PM 사이에 존재한다. 페이지 테이블은 각각의 프로세스가 가지며, 주어진 페이지와 그에 대응되는 프레임을 연결해준다.

![](/imgs/os/os29.png)

페이징이 적용된 환경에서, 주어진 VA로부터 VPN(Virtual Page Number)과 페이지 내에서의 offset을 뽑아낼 수 있다. 프로세서는 이를 이용해 페이지 테이블에서 그에 대응되는 PFN(Physical Frame Number)과 offset을 뽑고, 해당 페이지에 대한 권한을 확인한다. 그럼으로써 PM에 접근할 수 있게 된다.

![](/imgs/os/os30.png)

방금 VA에서 VPN과 offset을 뽑을 수 있다고 언급했었다. 32-bit 주소를 가정하자. 4KB의 페이지를 사용한다면, VPN을 결정하기 위해 20-bit가 필요하다. (2^8)\*(2^10)\*(2^2)이기 때문이다. 그럼 나머지 12-bit는 offset을 결정할 것이다. VA가 `0x7468`이라면? VPN은 `0x7`, offset은 `0x468`이 된다. 그리고 페이지 테이블에서 VPN `0x7`이 PFN `0x2`에 대응된다면, PA는 `0x2000+0x468=0x2468`이 된다. 그림에서 알 수 있듯, offset은 굳이 페이지 테이블에서 사용될 필요가 없다. 

## Paging Issues
Page table base register에 현재 프로세스가 가지는 페이지 테이블의 시작 주소가 저장되어 있는데(MMU에 의해 사용된다), 컨텍스트 전환이 일어나면 해당 레지스터는 자원을 점유할 프로세스에게 넘겨주어야 할 것이다. 페이지 테이블 자체는 메인 메모리 내에 저장되어 있기 때문에, 컨텍스트 전환 시엔 해당 레지스터의 정보만 저장 및 복구하면 된다.

페이지의 크기를 정하는 것도 중요한데, 페이지의 크기가 너무 작다면 그에 비례해 늘어난 최대 VPN으로 인해 페이지 테이블의 크기가 너무 커진다. 반대로 페이지 크기가 너무 크다면 페이지 당 남는 공간으로 인해 internal fragmentation이 발생할 것이다. 결국 적당한 타협점을 찾아야 하는 셈이다.

## Page-Level Access Control
위에서 보았듯, 페이지 테이블은 각 PTE(Page Table Entry)에 대한 접근 권한 정보를 포함하고 있다. 어떤 page가 페이지 테이블 위에 있다고 해서 무조건 어느 방식으로든 접근이 가능한 것은 아니다. 읽기 전용일 수도 있고, 쓰기도 가능할 수도 있기 때문이다. 우리는 이를 이용해 일종의 보호(protection)를 할 수 있다. 

## Page Table Entry
이제 우리는 각각의 PTE가 어떤 정보를 포함해야 하는지 알게 되었다. 우선, 매핑되는 frame이 있고 매핑이 유효(valid)함을 표시하기 위한 valid bit, 권한을 설정하기 위한 protection bit, 그리고 PFN 등이 있을 것이다. 또한, write-back 방법으로 쓰기를 구현한다고 할 때, 내용이 변경되었음을 표시하기 위한 modify bit, (교체 시 참고를 위해) 최근 참조되었는지의 여부를 표시하기 위한 reference bit 등도 추가할 수 있다.

디테일은 나중에 다시 알아볼 예정이다.

## Copy-on-Write
앞서, 세그먼테이션(segmentation)에서 copy-on-write라는 유용하고 효율적인 방법을 알아봤었다. 페이징을 사용했을 때도 이러한 방식으로 특정 영역을 공유할 수 있을까?

다수의 프로세스가 페이지 테이블에 같은 frame에 매핑되는 PTE를 각각 가지고 있으면 된다! 물론 이것만으로 끝나는 것은 아니고, 해당 프레임에 copy-on-write가 적용되었음을 알고 있어야 추후 쓰기 시 따로 복사가 가능하므로, frame에 대한 core map이 필요할 것이다.

UNIX에서 fork를 수행했을 때, 부모의 페이지 테이블을 자식에게 복사해주고, 모든 페이지를 읽기 전용으로 바꾼다. (부모든 자식이든) 특정 페이지로의 쓰기가 시도될 땐, 커널로 트랩을 걸어 frame을 복사하고 PTE를 업데이트하며, R-O였던 PTE를 쓰기가 가능하도록 변경한다.

## Sparse Address Space
Sparse가 무슨 단언지 몰라서 찾아봤다. '희박한, 드문'이란 뜻이랜다. 무식한 놈... 아무튼 sparse address space는














