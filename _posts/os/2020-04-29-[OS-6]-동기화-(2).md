---
title:  "[OS 6] 동기화 (2)"
tags: OS
toc: true
---

# Intro
저번 내용에 이어서 동기화를 위한 방법을 생각해보자.


# Locks
Lock에 관한 설명은 저번 포스팅에서 했었으니, 간단히 다시 한 번 정리해보자면, lock의 개념은 critical section에서 다수의 스레드의 serialization을 강제하는 효과가 있다. lock은 두 함수, `acquire`와 `release`에 의해 다루어진다. `acquire`는 lock이 사용 가능할 때까지 대기했다가, 이후 습득하는 함수다. `release`는 lock을 놓아줌으로써, 다른 대기자가 lock을 습득할 수 있도록 하는 함수다.

우리는 간단한 형태인 스핀락(spinlock)을 통해 그 동작 방식을 알아봤었다. 다만 여기엔 몇 가지 문제가 있었는데, Critical section이 길고 오래 걸린다면, 또 대기자가 많다면 대기에 따른 오버헤드와 자원 낭비가 많이 발생한다. 또, 경우에 따라 스핀락은 bounded waiting을 보장하지 않을 수 있어, starvation을 초래할 수도 있다. 하지만 단일 프로세서의 경우, spining을 통한 무한정 대기보다는 `yield`를 사용해 스케줄링을 양보함으로써 스피닝에 의한 CPU 자원 낭비를 해결할 수 있긴 하다.


# Interrupt
이전 포스팅에서, 우리는 atomic한 operation이 동기화에 어떤 기여를 할 수 있는지 알아보았다. Atomic operation을 구현하기 위해, 우리는 외부로부터의 컨텍스트 전환(context switching)을 피해야 한다. 이는 인터럽트를 비활성화함으로써 해결할 수 있다. 그런데 여기서 '인터럽트를 비활성화한다'라는 것에 대해 조금 더 생각해볼 필요가 있다.

우선, 인터럽트의 비활성화는 previleged instruction이다. 보통 prevelieged의 여부는, 자신 외의 무언가에게 영향을 줄 수 있는지로 판단된다. 예를 들어, 다른 프로세스의 가상 메모리의 접근은 previleged instruction이 당연하지만, 스스로의 가상 메모리를 밀어버리는 것은 그렇지 않다. 프로세스가 임의로 인터럽트를 차단할 수 있다면, 이는 그 프로세스가 CPU 자원을 독점할(monopolize) 가능성이 있다.

또, 인터럽트의 비활성화는 필요한 동안만 이루어져야 한다. 만약 disable-enable의 구간이 길다면, CPU 자원뿐 아니라, 여러 HW-related한 문제가 발생할 수 있다.

앞에서 언급한 문제와 인터럽트를 고려하여, lock을 다시 설계해보자.

`acquire`는 atomic해지기 위해, 시작 시 인터럽트를 비활성화한다. 만약 lock을 습득할 수 없다면, 스스로를 대기열에 넣고 대기 상태로 전환하고 점유를 넘겨주며, 습득 가능하면 lock을 습득한다. 이후 인터럽트를 활성화한다. `release` 또한 인터럽트의 비활성화와 활성화를 포함한다. 단순히 lock을 놓기만 하던 예전과 달리, 대기열에 대한 관리를 수반해야 함을 주의하자. 물론 이들은 커널 모드에서 동작한다. 인터럽트의 비활성화 및 활성화가 이루어져야 하기 때문이다.

여기서 생각해봐야 할 점이 하나 있다. "`acquire`에서 점유를 넘겨주면, 즉 스위칭이 일어나면 비활성화된 인터럽트는 어떻게 되는가?"다. 스레드 간 컨텍스트 전환이 일어나면, 점유를 받은 스레드는 인터럽트를 다시 활성화해야 할 의무가 있다. 


# Semaphores
세마포어(semaphores)는 lock의 일반화로 볼 수 있는 동기화 도구로, 다익스트라(Dijkstra)가 처음 고안 및 정의했다. 생각해보면 다익스트라도 참 이것저것 많이 했다... 아무튼 그래서 세마포어가 무엇인지 알아보자.

세마포어는 오직 두 가지의 atomic operation만을 지원하는 non-negative integer S다:

- P() : 세마포어가 양수가 될 때까지 기다리는 atomic operation이다. 양수가 되었다면, 세마포어를 1만큼 감소시킨다. `wait`의 역할을 한다고 보면 된다.
- V() : P에서 대기 중인 대상을 깨우고 세마포어를 1 증가시키는 atomic operation이다. `signal`의 역할을 한다고 보면 된다.

우리는 세마포어라는 개념으로, critical section 문제와 상호 배제(mutual exclusion)뿐 아니라, 일정 수의 접근 및 사용만이 허용되는 한정된 자원에도 동기화를 적용할 수 있게 된다. 물론, 상호 배제를 위해 세마포어를 사용할 수도 있다. 이는 이진(binary) 세마포어로, 이것에 의한 lock을 mutex lock이라 부른다. 여기에 대조되는 개념은 카운팅(counting) 세마포어로, 어떤 정수(N)를 초기값으로 가져, 그 수만큼의 액세스를 허용한다.

세마포어는 스케줄링에서의 constraint로도 사용할 수 있다. 두 스레드(T1, T2)를 생각해보자. T1이 T2로부터의 시그널을 기다리는 상황을 만들고 싶다면, 즉, T2가 어떤 constraint가 만족되었을 때 T1을 스케줄하고 싶다면 어떻게 해야 할까? 초기값이 0인 세마포어를 도입해, T1에게 P를 적용시키고, constraint가 만족되었을 때 V를 적용시키면 된다.

그래서, 세마포어를 어떻게 구현하면 좋을까? 우선 세마포어 자체는 자신의 정수값과 세마포어가 적용될 프로세스 리스트를 포함한다.

    typedef struct {
      int value;
      struct process * list;
    } semaphore;

우선 앞서 보았듯, 스핀락과 같은 방식보다는 대기열에 스스로를 집어넣고 대기시키는 게 좋은 방법일 듯하다. 따라서, 그에 맞는 적절한 내부 함수 `wait`와 `wakeup`을 구현해야 한다.

    void wait(semaphore *S) {
      S->value--;
      if (S->value < 0) {
        add this process to S->list;
        sleep();
      } 
    }

    void signal(semaphore *S) {
      S->value++;
      if (S->value <= 0) {
        remove a process P from S->list;
        wakeup(P);
      }
    }
    

# 마치며
이번엔 짧게 여기서 끝내려고 한다. 다음엔 고전적인 동기화 문제들을 알아보고, 동기화 방법들이 그러한 문제를 해결해줄 수 있는지로 동기화 방법의 적절성을 검토해보려 한다. 
