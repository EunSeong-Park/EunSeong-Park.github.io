---
title:  "[MIPS 4] Procedure Call"
tags: MIPS
toc: true
---

# Intro
프로시저의 호출 방법과 그 때 내부에서 어떤 일이 발생하는지 알아보자. 다른 프로시저를 호출하지 않는 leaf 프로시저와, 다른 프로시저를 호출하는 non-leaf 프로시저로 나누어 볼 것이다. 물론 leaf 프로시저가 간단하므로 이걸 먼저 알아볼 예정이다.


# Procedure Call
## Leaf Procedure
Leaf 프로시저는 다른 프로시저를 호출하지 않는다. 그래서 간단하고, 프로시저 호출 및 리턴에 대한 과정을 심플하게 살펴볼 수 있다. 아무튼 이러한 프로시저를 호출 하면, 어떤 일들이 일어날까? 또, 호출을 위해 어떤 과정을 거쳐야 할까?

1. 파라미터를 적절한 레지스터(주로 a0-a3), 또는 스택에 저장한다.
2. 프로시저로 제어를 이동한다.
3. 프로시저를 위한 공간(전용 스택 등)을 할당한다.
4. 프로시저가 동작한다.
5. 호출자가 필요로 하는 리턴값을 저장한다.
6. 호출했던 위치 쪽으로 제어를 리턴한다.

그러면 이 과정을 MIPS에선 이를 어떻게 구현할까? 바로 jump 인스트럭션을 이용해 프로시저 콜/리턴을 구현한다.

`jal Procedure_Label`을 통해, 돌아올 주소(바로 다음 명령어 주소)를 ra 레지스터에 저장하고, 프로시저에 해당하는 주소로 점프한다. 프로시저가 리턴을 해야 할 땐, `ja $ra`를 통해 ra 레지스터의 값을 PC에 대입함으로써 리턴할 수 있다.

## Non-Leaf Procedure
복합적인 프로시저 콜이 일어나면 상황은 조금 복잡해진다. 구조 자체가 복잡해지는 것도 있지만, 피호출자(callee)가 호출자(caller)가 사용할 자원을 훼손할 수 있기 때문이다. 그래서, 호출자는 일부 데이터(리턴 주소, 호출 후 사용할 arg, temp)를 스택에 저장해놓고 프로시저를 호출해야 한다.

대표적인 non-leaf 프로시저의 예시는 재귀함수일 것이다. Input, `n`을 받고 그것의 팩토리얼을 리턴하는 함수를 구현해보자. 우선 C로 함수를 작성하면 아래와 같을 것이다.

    int fact (int n){
        if (n < 1) return 1;
        else return n*fact(n-1);
    }

이제 MIPS로 옮겨보자.

Value | Reg
---|---
n | a0
return value | v0

    fact:
          addi  $sp, $sp, -8    # 데이터 두 개를 넣기 위해 스택에 8 바이트 할당
          sw    $ra, 4($sp)     # 리턴 주소 저장
          sw    $a0, 0($sp)     # argument(n) 저장

          slti  $t0, $a0, 1     # n < 1이면 t0 값 세팅(1)
          beq   $t0, $r0, L1    # n >= 1이면 (t0 == 0) 분기

          addi  $v0, $r0, 1     # 리턴값 1로 설정
          addi  $sp, $sp, 8     # 스택 pop
          jr    $ra             # 리턴

          # n >= 1인 경우
    L1:   addi  $a0, $a0, -1    # n -= 1
          jal   fact            # f(n-1) 호출

          # 호출 후엔 v0에 f(n-1) 값이 저장된다.
          lw    $a0, 0($sp)     # 저장한 n 값 복구
          lw    $ra, 4($sp)     # 저장한 리턴 주소 복구
          addi  $sp, $sp, 8     # 스택 pop

          mul   $v0, $a0, $v0   # rval(f(n)) = n * rval(f(n-1))
          jr    $ra             # 리턴
      
위 코드에서, 함수 호출 전에 미리 리턴 주소와 (이후에 써야하는) 인자를 저장해놓은 것을 확인할 수 있다.


# Memory
메모리 구조는 질리도록 봐서 사진같은 건 따로 안구했다. 아무튼 Reserved되는 영역이 있고, 코드가 저장된 text 영역, 정적 데이터를 저장하는 영역과 동적 데이터를 저장하는 영역이 있을 것이다.

여기서 정적(static) 데이터라 하면, C에서의 static 변수, 고정 크기의 배열과 문자열(string)이 해당될 것이다. 이것과 동적(dynamic) 데이터는 gp(28번) 레지스터에 의해 그 경계가 정해진다. 

동적 데이터 영역엔 동적 할당되는 데이터가 저장되는 힙(heap)과 함수 내 데이터들을 저장할 스택(stack)이 포함될 것이다.

## Stack
스택(stack)은 메인 메모리의 일부로, MIPS에선 스택이 높은 주소에서 낮은 주소로 grow한다. 즉, 스택을 쌓을 수록 스택 포인터의 주소는 그 값이 작아지는 것이다. 이 점을 알고 있어야 코딩 시 스택 공간을 할당할 때 혼동이 없을 것이다.

sp(29번) 레지스터에 의해서 스택의 top 부분(즉, 가장 낮은 주소)이 포인팅되며, 그 스택의 프레임은 fp(30번) 레지스터에 의해 포인팅된다.



      
