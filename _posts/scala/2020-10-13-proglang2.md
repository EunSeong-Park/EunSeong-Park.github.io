---
title : "Designing Programming Language 2"
tags: Scala Programming-Language
---

# Intro



# Nameless proc
잠깐 돌아가서 스코핑에 관해 조금 더 알아보자. 앞서 언급하였듯 우리는 scoping에 대해 lexical(static) / dynamic scoping 중 하나를 채택할 수 있으며, 일반적으로 lexical scoping이 더 typical하다. 이번엔 lexical scoping에 대해 조금 더 자세히 알아보고, lexical scoping으로 인해 구현할 수 있는 nameless representation이 적용된, **nameless proc** 언어를 세워보자.

## More about Lexical Scoping  
### Static / Dynamic Property
계속 static / dynamic이라고 표현하지만, 왜 이러한 term을 사용하는 걸까? 여기서 각각의 개념도 짚고 넘어가자. 프로그램에서, static / dynamic한 property는 보통 다음을 의미한다.

- Static property: can be computed w/o executing the program
- Dynamic property: can be determined only by executing the program(run-time).
  
이러한 점에서 보아, 변수의 타입(type)은 C/C++에선 static이나, Python에선 dynamic하다.

### Variables
모두가 알고 있겠지만, 변수는 두 방식으로 프로그래밍 언어에서 나타난다.

- Declaration: 어떤 값(value)의 이름으로서 변수를 설정한다.
- Reference: 변수에 대응되는 값을 사용하기 위해 참조한다.

여기서, 변수의 참조는 그 변수와 연관된 선언(declaration)과 변수에 대한 값(value)에 bound된다고 표현된다.

### Lexical Depth
우리가 변수를 참조(reference)할 때, 우린 그 참조에 매칭되는 선언(declaration)을 찾아야 한다. 예를 들어, 아래 코드를 보자.

```
let x = 1
  in let y = 2
    in x + y
```

Line 3의 expression을 evaluate하기 위해, 우리는 line 1, 2의 declaration을 찾아야 하고, 직관적으로 우린 $x$가 $y$보다 더 멀리 있음을 알 수 있다. Lexical depth는 이처럼 "얼마나 declaration이 멀리 떨어져있는가?"에 대한 지표가 된다. 다음과 같이 정의하자.

> Lexical depth: # of declarations crossed to find the corresponding declaration

이러한 정의에 따르면, 위 예시에서 $x$의 lexical depth는 $1$, $y$는 $0$이다.

### Lexical Address
표현식 각각에서 변수가 가지는 lexical depth는 reference를 bind하는 declaration을 uniquely identify한다. 그렇다면, 우리는 변수의 이름을 쓸 필요 없이 lexical depth만으로 그에 대응하는 declaration을 찾을 수 있지 않을까? 그런 아이디어에서, 변수 이름을 lexical depth로 치환한 것을 lexical address라 한다.

위의 lexical depth 예시는 다음과 같이 치환될 수 있다.

```
let 1
  in let 2
    in #1 + #0
```

이러한 표기를 nameless representation, 혹은 De Bruijn representation이라고 한다. 말 나온 김에 한 두개 더 해볼까?

```
(let x = 37 
  in proc y
    let z = y - x
      in z - y) 10

(let 37
  in proc
    let #0 - #1
      in #0 - #1) 10
```


## Nameless proc
이제, 우리가 설계한 **proc**에서, 변수 이름을 제거해보자. 아래는 nameless proc의 syntax가 되겠다.

$$ P \to E $$ 
<br>$$ E \to n \in \mathbb{Z} $$
<br>$$  \;\;\;\;\;\mid\;\; #n $$ 
<br>$$  \;\;\;\;\;\mid\;\; E + E $$ 
<br>$$  \;\;\;\;\;\mid\;\; E - E $$
<br>$$  \;\;\;\;\;\mid\;\; iszero \;E $$
<br>$$  \;\;\;\;\;\mid\;\; if\; E\; then\; E \;else E $$
<br>$$  \;\;\;\;\;\mid\;\; let\; E \;in\; E $$
<br>$$  \;\;\;\;\;\mid\;\; (E)$$
<br>$$  \;\;\;\;\;\mid\;\; proc \;E$$
<br>$$  \;\;\;\;\;\mid\;\; E\; E$$

이제 도메인을 결정해보자.

$$\begin{matrix}
Val: & \mathbb Z + Bool + Procedure\\
Procedure: & E \times Env\\
Env: & Val*\\
\end{matrix}
$$

Env는 어떻게 표현하면 좋을까? 가장 간단한 방법은 해시맵이나 튜플 리스트를 사용하는 것이다.

```
(let x = 37 
  in proc y
    let z = y - x
      in z - y) 10

(let 37
  in proc
    let #0 - #1
      in #0 - #1) 10
```

![](imgs/../../../imgs/scala/3.png)

(똥그림 ㅈㅅ) 이렇게 정확히 lexical address에 대응되는 값을 찾아낼 수 있다!

이제 inference rule을 살펴볼까?

$$
\frac{}{\rho \vdash \#n \implies \rho_n} \\ \; \\
\frac{\rho \vdash E_1 \implies v_1 \;\;\; v_1::\rho \vdash E_2 \implies v}{\rho \vdash let\;E_1\;in\;E_2 \implies v} \\ \; \\
\frac{}{\rho \vdash proc\; E \implies (E, \rho)}
\\ \; \\ \frac{\rho \vdash E_1 \implies (E, \rho')\;\;\;\rho' \vdash E_2 \implies v\;\;\; v::\rho'\vdash E_2 \implies v'}{\rho \vdash E_1 \; E_2 \implies v'}
$$

허이고... 위의 예시를 통해 알아보자.

## Example
```
(let 37
  in proc
    let #0 - #1
      in #0 - #1) 10
```
우선, 