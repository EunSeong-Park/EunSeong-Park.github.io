---
title : "Designing Programming Language 3"
tags: Programming-Language
---

# Intro
우리는 지금까지 프로그래밍 언어를 설계해왔다. 요소를 하나하나 늘려가고 정교하게 만들며, 오늘날 실제로 사용하는 언어에 비슷할 정도로 언어 체계를 확장하는 게 목표다. 그래서 이번엔 뭘 하느냐? **C, C++**에 있는 요소인, **구조체(structure)**와 **포인터(pointer)**를 구현할 것이다! 또, Java 등에서 사용하는 **가비지 컬렉션(GC)**의 원리를 이해하여 구현해보자. 생각만 해도 막막하다...

아무튼, 여기서부터 시작한다.

$$\begin{aligned}
P &\to E \\ 
E &\to n \;\vert\;x \\
&\;\;\vert\; E+E\;\vert\;E-E \\
&\;\;\vert\; iszero\; E\;\vert\;if\;E\;then\;E\;else\;E \\
&\;\;\vert\; let\; x=E\;in\;E\\
&\;\;\vert\;proc\;x\;E\;\vert\;E\;E\;\vert\;E\;\langle x\rangle \\
&\;\;\vert\; !\;E\;\vert\; E:=E\; \\
&\;\;\vert\; E;E\;\vert\;(E)\\
\end{aligned}$$

$$\begin{aligned}
Val &= \mathbb Z + Bool+Proc \\
Proc &= Val \times E \times Env \\
\rho \in Env &= Val \to Loc \\
\sigma \in Mem &= Loc \to Val
\end{aligned}$$



# Records
**Records**, 또는 **structured data**를 먼저 알아보도록 하자. **C**에서는 보통 여러 멤버들이 연속적으로 저장되어 하나의 구조체(`struct`)를 이루었다.

```cpp
struct record{
    bool flag;
    int num1;
    int num2;
};
```

## Requirements
우리는 record를 구현할 때, 다음과 같은 사항들을 지원토록 해야한다.

- Record 전체나 각각의 멤버에 접근할 수 있다.
- Record가 포함하는 멤버의 값을 변경할 수 있다.
- Record는 다른 record를 포함할 수 있다. (다른 종류라도)
- Record는 아무것도 포함하지 않을 수도 있다. (empty record)
  
## Language Extension for Records
이제 언어 체계(syntax, domain, semantics)를 확장해보자. 우선 syntax부터!

$$\begin{aligned}
E &\to \cdots \\
&\;\;\vert\; \{\} \\
&\;\;\vert\; \{ x:=E, y:=E, \cdots \} \\
&\;\;\vert\; E.x \\
&\;\;\vert\; E.x := E
\end{aligned}$$

꽤 직관적인 syntax다. Domain은 다음과 같다.

$$\begin{aligned}
Val &= \mathbb Z + Bool+Proc+ \{ \cdot \} + Record \\
Proc &= Val \times E \times Env \\
r \in Record &= Field \to Loc \\
\rho \in Env &= Val \to Loc \\
\sigma \in Mem &= Loc \to Val
\end{aligned}$$

마지막으로 semantics까지 정리하면, 각각이 무엇을 의미하는지 쉽게 알 수 있을 것이다.

$$
\frac{}{\rho, \sigma \vdash \{ \} \implies \cdot, \sigma}
$$

$$
\frac{\rho,\sigma \vdash E_1 \implies v_1, \sigma_1 \quad \rho, \sigma_1 \vdash E_2 \implies v_2,\sigma_2\quad l_1, l_2 \notin Dom(\sigma_2)}
{\rho, \sigma \vdash \{ x:=E_1, y:=E_2 \} \implies \{ x \mapsto l_1, y \mapsto l_2 \} , [l_1 \mapsto v_1, l_2 \mapsto v_2]\sigma_2}
$$

$$
\frac
{\rho, \sigma \vdash E \implies r, \sigma_1}
{\rho, \sigma \vdash E.x \implies \sigma_1(r(x)), \sigma_1}
$$

$$
\frac
{\rho, \sigma \vdash E_1 \implies r,\sigma_1 \quad \rho, \sigma_1 \vdash E_2 \implies v, \sigma_2}
{\rho, \sigma \vdash E_1.x := E_2 \implies v, [r(x) \mapsto v]\sigma_2}
$$

부가적인 설명은 필요 없을 것 같다.

# Pointers
이제 포인터다! **C**나 **C++**을 처음 배울 때 포인터가 그렇게 어려웠는데, 이젠 포인터를 물 흐르듯 자연스럽게 쓸 수 있게 되었다. (또한 그래야만 하고)

우리가 설계하는 언어를 생각해보자. 우리는 포인터를 도입함으로써 다음과 같은 프로그램을 만들 수 있다.

```
let x = 1
  in let y = &x
    in *y := *y + 2
```

## Requirements
우리의 포인터는 다음과 같은 사항들을 지원할 수 있어야 한다.

- 어떤 variable의 location($Loc$)을 value로 다룰 수 있다.
- 포인터를 어떤 record의 멤버에 대해서도 사용할 수 있다.

## Language Extension for Pointers
늘 해왔던 것처럼, syntax, domain, 그리고 semantics를 새로 정의하자.

$$\begin{aligned}
E &\to \cdots \\
&\;\;\vert\; \{\} \\
&\;\;\vert\; \{ x:=E, y:=E, \cdots \} \\
&\;\;\vert\; E.x \\
&\;\;\vert\; E.x := E
\end{aligned}$$