---
title:  "[Algorithms 3] 확률론적 분석"
tags: Algorithms
toc: true
key: algo3
---

# Probabilitic Analysis
고정 사이즈의 행렬 곱과 같은 알고리즘과 달리, 어떤 문제와 어떤 알고리즘은 그것의 퍼포먼스가 input에 의존한다.

아주 친숙한 예시로 정렬(sorting)이 있다. 어떤 초보 개발자가 4중 for문을 사용한 흉악한 정렬 알고리즘을 고안해냈다고 생각해보자(정작 본인은 자신의 알고리즘의 코스트를 모른다, 알고 싶지도 않을 수도). 알고리즘을 짰으니 적당한 input을 넣고 테스트를 분명 할 것이다. 이 때, input이 1-2-3-4-5-6-7-8-9인 already-sorted array였다면 어떨까? 한방에 정렬이 끝났으니 이 알고리즘은 O(1)이라고 해도 될까? 

우리는 모든 경우의 input을 고려해야 한다. 모든 가능성에 대한 평균 코스트를 구하면(꼭 평균이 아니어도 될 것이다), 위의 예시보단 그 알고리즘의 퍼포먼스를 더 잘 대표할 수 있을 것이다.

아무튼 이번엔 아래의 hiring problem과 함께, probabilistic anaysis를 위한 기본 지식을 쌓아보자.

## Hiring Problem
다음과 같은 상황을 생각해보자.

> 당신은 새로운 직원을 한 명 고용해야 하고, 이를 위해 고용 에이전시는 일정 비용(Ci)을 받고 매일 한 명의 후보를 소개해준다. 당신은 면접 후 고용 여부를 바로 결정해야 하고, 만약 고용을 결정했다면 원래 직원은 바로 해고해야 한다. 이 과정에서도 일정 비용(Ch)을 지출해야 한다. 당신은 최고의 직원을, 아주 급하게 원하기 때문에, 현재 직원보다 낫다면 반드시 고용하게 된다.

별 또라이 사장을 다 보겠다. 아무튼 요약하면, 매 trial마다 반드시 나가고, 후보가 점점 나아진다면 추가 비용이 더 발생하게 될 것이다.

![](/imgs/algorithm/algo2.png)

이 상황에서, 면접 횟수를 `n`, 갱신 횟수를 `m`이라고 하면 O(nCi + mCh)의 코스트가 발생한다. 주어진 `n`에 대해, best-case는 처음 면접에서 최고의 직원을 만나 이후에 갱신을 하지 않는 경우고, O(nCi + Ch)의 코스트가 발생한다. 최악의 경우는 매 면접마다 직원이 아주 조금씩 나아져, 매 번 갱신을 하는 경우로, O(nCi + nCh)의 코스트가 발생한다. 이처럼, 경우에 따라 같은 방식을 적용함에도 불구하고 코스트가 달라진다.

각 직원들의 수준이 totally ordered되어 있다고 가정하자. 그 순서에 따라 인덱스를 매기면, 가능한 모든 input은 [1,2, ..., n]의 순열(permutation)과 같을 것이다.

## Randomized Input
그런데 짚고 넘어가야 할 점이 있다. 알고리즘에서 무작위하다는 건 무엇이고, 그런 무작위함을 어떻게 만들어낼 수 있을까?

우리는 대부분의 경우, population에서 각각의 event가 동일한 확률로 발생함을 가정한다. 즉, 주사위에서 1이 뜰 확률과 4가 뜰 확률이 "완전히" 동일하다는 것이다. 이것이 현실에서 잘 적용될까? 주사위에도 미세한 눈금 간의 무게 차가 있을 테고, 던지는 방식도 매 시도마다 달라질 것이며 결과에 영향을 줄 것이다. 컴퓨터라고 마찬가지일까? 무작위로, 그것도 동일한 확률로 회로를 골라 출력하는 DEMUX나 다른 게이트가 있을까?

실제로 컴퓨터에서 무작위의 무언가를 수행하는 기능은 전부 "랜덤처럼 보일" 뿐이다. 다만 실제로 거의 랜덤이 맞고, 대부분의 경우 꽤 랜덤스럽다(이걸 어떻게 확인해야 할지도 잘 모르겠지만). 

## Running Time
대부분 알고리즘의 평가는 (간접적이든 직접적이든) 그것의 실행 시간을 통해 이루어질 것이다. 여기서 용어를 확실히 정리하고 가자.

- Average-case running time: 평균적인 경우의 문제를 해결하는 데 걸린 시간
- Expected running time: (알고리즘이 무작위 선택을 수반하는 경우) 모든 running time의 expectation

## Indicator Random Variable
아주 심플한 discrete random variable이다. 특정 사건 `A`에 대해, `A`가 발생하면 1, 발생하지 않으면 0을 가진다.

![](/imgs/algorithm/algo3.png)

그 정의와 성질로 인해, `I`의 expectation은 `A`의 발생 확률과 같다. 어차피 예전에 배웠지만, 알아나 두자.

## Hiring Problem, Again 
이를 통해, 위의 hiring problem을 다시 살펴보자. 주요 포인트는 __직원을 평균적으로 몇 번이나 갈아치워야 하는가?__ 다. 이를 위해, i-th 후보가 고용되는 사건을 indicator로 Xi = I와 같이 나타내어 보자. 총 고용 횟수는 X = X1 + X2 + ... + Xn과 같다. 그에 따라 평균도 EX = EX1 + EX2 + ... + EXn = PX1 + PX2 + ... PXn과 같다.

Xi 각각의 확률은 1/i다. 왜냐? 어떤 i에 대해, [1-th, ..., i-th] 그룹에서 i-th가 최댓값이어야 하고, 이는 최댓값이 배열의 마지막에 와야 함을 의미한다(그 앞은 어떻게 되는 상관없다). 즉, 전체 순열 i!에서, 우리가 주목하는 사건은 (i-1)!이고, 그래서 그 확률은 1/i가 된다. 아무튼 이러면 EX는 조화수열의 합, Hn이 되고, 이는 ln n + O(1)이다. 결론적으로, average-case에서의 고용 비용은 O(Chln(n))이 된다.

![](/imgs/algorithm/algo4.png)

반면, 이렇게 알고리즘 내에서 randomization을 수행한다면, 우리는 알고리즘을 돌릴 때마다 다른 코스트를 얻게 될 것이다. 이것의 expectation이 expected cost가 되겠는데, 그것 또한 위에서 구한 average-case cost와 같을 것이다.

