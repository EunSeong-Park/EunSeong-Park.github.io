---
title:  "[Software Engineering 1] Testing"
tags: Software-Engineering
toc: true
---

# Intro
비단 오류뿐만 아니라 의도하지 않은 결과, 흐름, 혹은 예상보다 낮은 퍼포먼스 등과 같이, 프로그램이 의도하지 않은 방향으로 실행되는 경우는 아주 많다. 테스트는 이를 잡아내고 수정 및 보수하기 위함이며, 이를 위한 체계적인 방법들이 많다. 

여기선 테스트에 관한 몇 가지 기본적인 개념을 예시와 함께 알아보고, 적절한 테스트 스위트를 만들기 위한 방법을 살펴보자.


# Basic Concepts
## Fault / Error / Failure
Fault, error, failure, 이 세 단어는 비슷한 의미로 사용되지만, 몇 가지 분명한 차이점이 있다. 

Type | Description
---|---
Failure | 외부로 드러나는 incorrect behavior
Error | 프로그램의 incorrect intenal state 
Fault | SW의 정적인 결함

Fault는 error를 야기할 수도 있고, 그렇지 않을 수도 있다. 또한, error는 failure를 야기할 수도 있고, 그렇지 않을 수도 있다. 예를 들어, `{1, 2, 3, 4, 5}`로 저장되어야할 어떤 배열, `A`가 `{1, 2, 3, 4, 6}`으로 저장되었다고 치자. 그렇게 만든 코드를 fault라 부르며, 그로 인한 이 잘못된 상태를 error라 부른다. 만약 `A[4]`를 읽어 출력하려 한다면 이는 failure로 이어지지만, 다른 부분을 읽는다면 failure로 이어지지 않는다.

## Coverage
어떤 경우에 error가, fault가, 그리고 failure가 일어날까? 우리는 테스트를 통해 이를 확인하고 싶다. 하지만 이는 실제로 꽤 어려운 일이다. 예시로 아래 코드를 보자.

```c
if (x - 100 <= 0)
    if (y - 100 <= 0)
        if (x+y == 200)
            crash();
```
여기서 `crash()`는 언제 일어날까? 오직 `(100, 100)`인 경우뿐이다. 이 때 문제가 드러나는데, `int` 타입을 가정했을 때, $2^{31} * 2^{31}$의 케이스를 중에 단 하나만 fault를 발생시킨다. 

이런 경우 exhaustive한 테스트는 실질적으로 불가능하다. 너무 코스트가 크기 때문이다. 그렇다고 랜덤으로 인풋을 결정해 테스트한다고 해서 달라질까? 이 또한 0에 가까운 확률이다. 이런!

우리는 최대한 많은 경우를 고려해 테스트하고 싶지만, 그와 동시에 효율적인 테스트를 하고 싶다. 무조건 많은 수의 테스트가 왕도는 아닌 셈이다. 이제, 효과적이면서도 효율적인 테스트를 위해, 커버리지(Coverage)라는 개념을 도입해보자.

커버리지의 기본 아이디어는 이렇다. "프로그램의 많은 부분이 커버될 수록, 버그를 찾아낼 가능성이 더 높다!" 그런데, 여기서 "많은 부분"이란 정확히 무엇을 의미하는 걸까? 여러 측면에서 Coverage metrics를 정의할 수 있다.

### Line Coverage
라인 커버리지는 테스트 케이스들에 의해 실행된 소스 코드 라인의 비율이다. 가장 직관적이고 간단한 메트릭으로 볼 수 있다. 그런데,

```c
for (int i=0; i < n; i++>){sum += i; product *= i} printf("done.");
```

이걸 한 줄로 보는 게 정녕 맞을까?

### Statement Coverage
줄 대신, 이젠 구문(statement)을 기준으로 실행된 비율을 따져볼 수 있다. 라인 커버리지보다 조금 더 괜찮아보이지만, 모든 구문을 실행하는 게 반드시 완벽한 테스트가 됨을 보장할 수 있을까? 아래 예시를 보자.

```cpp
int x, y;
if (x < y) x += 10000;
if (x > y) y += 10000;
cout << x << y;
```

여기에 테스트 케이스, `{x, y} = {100, 1000}, {1000, 2000}`을 넣는다고 가정하자. 분명 모든 statement가 실행된다. 하지만 이 테스트 케이스 셋에선 첫 번째 `if`를 건너지 않는 flow가 없다. 뭔가 부족한 느낌이다.

### Branch Coverage
브랜치 커버리지는 테스트 케이스에 의해 분기가 실행되는 비율이다. 즉, control flow graph에서 edge(간선?)들을 얼마나 실행시키는지에 대한 지표다. 위의 예시 코드를 CFG(Control Flow Graph)로 표현해보자.

![](/imgs/se/se1.png)

(그림판 ㅈㅅ) 테스트 케이스가 커버하지 못하는 분기(edge)가 있음을 명확히 파악할 수 있다. 또, 이러한 점에서, 다음과 같은 사실을 알 수 있다.

> 테스트가 모든 분기를 커버한다면 모든 구문 또한 커버된다. 하지만 모든 구문을 커버한다고 모든 분기의 커버를 보장하지는 않는다.

