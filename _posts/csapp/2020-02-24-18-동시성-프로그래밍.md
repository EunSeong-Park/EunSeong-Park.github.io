---
title:  "[CS:APP 18] 동시성 프로그래밍"
toc: true
tags: CS:APP
---

# Intro
드디어 마지막 파트다! 앞에서 동시성(concurrency)에 대해 잠깐 그 개념을 짚고 넘어갔다. 커널에 의해 다수의 애플리케이션이 돌아가는 걸 동시성을 통해 설명했는데, 이번엔 애플리케이션 수준에서 동시성이 어떻게 이루어지고, 이걸 어떻게 구현해낼 수 있는지에 대해 알아볼 예정이다. 우선 동시성 프로그램을 작성하기 위한 방법을 여럿 알아보고 이들을 비교해보려 한다. 여기는 한 포스트 안에 간단하게 끝낼 예정이다. 어차피 학교에서 이것과 관한 주제를 더 깊게 배울 예정이고 하니, 짧게 이해를 하는 정도에서 그치고 싶다.

책에선 앞에서 설계한 간단한 웹 서버 예제를 가져와 이를 통해 설명하...지만 코딩less하게 개념을 짚고 넘어가려고 한다. 사실상 다 생략했지만 대충 맥락은 이해할 수 있을 거라 생각한다. 와, 날먹!


# Concurrency
Logical control flow에 대해 배울 때 언급했듯, 동시성(concurrency)이란 여러 흐름의 시간적 중첩을 의미한다. EOF에선 커널이 예외나 시그널 등을 처리할 때, 여러 프로그램을 구동시킬 때 등에서 동시성이 나타났는데, 동시성은 커널 수준이 아닌 애플리케이션 수준에서도 일어날 수 있다. 어떤 측면에서 애플리케이션 수준의 동시성이 유용할까?

- 디스크처럼 느린 I/O 디바이스로부터 데이터를 가져오려 할 때, 기다리는 동안 다른 작업을 수행하도록 할 수 있다.
- 한 서버에서 어떤 클라이언트가 종료될 때까지 (다른 클라이언트의 작업을 막으며) 기다리지 않고 다수의 클라이언트를 처리한다.
- 애플리케이션에서 특정 작업이 수행되는 도중 별도의 요청을 처리할 수 있다.
- 멀티 코어 머신에서 병렬 계산 및 작업을 수행할 수 있다.

예시로, 동시성이 부재한 반복실행형의(iterative) 서버에서 발생하는 문제점을 통해 동시성의 중요성을 알아보자. PPT에 나온 예시다. 

![](/imgs/csapp/97.png)

클라이언트 1이 먼저 접속하였기 때문에 클라이언트 2는 클라이언트 1이 `close`로 그 연결을 종료할 때까지 대기해야 한다. 이런 상황에서는 다음과 같은 문제가 발생할 수도 있다.

![](/imgs/csapp/98.png)

클라이언트 1이 연결을 종료하지 않는다면 클라이언트 2는 서버에게 특정 요청을 할 수 없게 된다.

이제 동시성이 중요함을 알게 되었으니, 이러한 동시성을 어떻게 구현해낼지에 대해 알아보자. 보통은 세 가지의 동시성 프로그램을 위한 방법이 있는데, 각각의 방법을 위와 같은 웹 서버의 관점에서 알아볼 것이다.

1. Process-based
2. Event-based (I/O multiplexing)
3. Thread-based


# Process-Based Conccurent Programming
프로세스를 이용한 방법은 다른 방법보다 간단하고, 우리가 이미 알고 있는 친숙한 내용을 베이스로 한다. 클라이언트가 연결 요청을 할 때마다, 서버의 부모 프로세스는 새로운 자식 프로세스를 생성해 클라이언트에게 서비스를 제공한다. 그리고 연결이 종료되면 자식 프로세스 또한 종료되며 메모리 누수를 막기 위해 좀비가 된 자식을 reap해야 한다. 

![](/imgs/csapp/99.png)

위 상황에서 연결이 어떻게 이루어지는지 확인해보자.

![](/imgs/csapp/100.png)

우선 서버는 듣기 식별자(listening descriptor), `listenfd`로의 연결 요청을 기다리며, 이후 클라이언트가 `connect`를 통해 연결을 요청한다.

![](/imgs/csapp/101.png)

서버는 연결 식별자, `connfd`를 리턴하고, `fork`로 자식 프로세스를 생성하여 클라이언트에게 서비스하도록 한다. 이 때, `clientfd`와 `connfd` 사이의 연결이 수립된다. 이 때 다른 클라이언트가 서버에게 연결 요청을 한다면? 서버는 새로운 연결 식별자를 리턴하고, 새로운 자식을 `fork`하며, 그 자식이 새 클라이언트에게 서비스할 것이다.

이 때 중요한 점은,

1. 각 클라이언트는 독립적인 자식 프로세스에 의해 서비스를 받는다.
2. 부모와 자식은 `listenfd`와 `connfd`에 대한 사본(copy)를 가지고 있다.

2번이 특히 중요한데, 우선 부모는 연결이 성립된 후 각 자식의 연결 식별자를 전혀 필요로 하지 않는다. 즉, 쓸모가 없다. 게다가 만약 부모가 어떤 연결 식별자의 사본을 닫지 않으면, 그 식별자에 대한 파일 테이블 엔트리가 반환되지 않아, 결과적으로 메모리 누수를 초래할 것이다. 자식 프로세스 입장에서는 (이미 연결되었으므로) `listenfd`가 필요 없을 것이다. 따라서 자식도 `listenfd`를 닫는 게 권장된다.

프로세스 기반의 서버는 뚜렷한 특징과 장단점을 가진다.

- 프로세스 간 식별자와 사용자 주소 공간은 공유되지 않고, 파일 테이블은 공유된다. 이로 인해 프로세스 간 침범으로 발생하는 오류가 없다.
- 구현이 간단하고 직관적인 모델이다.
- 프로세스 제어에 의한 오버헤드가 발생한다.
- 프로세스 간 데이터를 공유하기 위해 명시적인 IPC(InterProcess Communication) 메커니즘을 사용해야 한다.


# Event-Based Concurrent Programming
다음과 같은 상황을 생각해보자. 한 클라이언트는 서버에게 연결 요청을 보내려고 하며, 다른 클라이언트는 커맨드 라인을 타이핑하고 있다. 만약 서버가 위의 방법을 사용하지 않는, 즉, 새 프로세스를 생성하지 않는 서버라면 어떻게 해야할까? `accept`에서 연결 요청을 기다리면 입력 명령을 처리하지 못하며, `read`에서 입력 명령을 기다리면 연결 요청을 처리할 수 없다.

I/O 다중화(multiplexing)라고 부르는 기술을 이용하면 이러한 문제를 해결할 수 있다. I/O 다중화가 무엇인지에 대해 알기 전, 우선, 다중화라는 용어에 대해 친숙해질 필요가 있다. 디지털 로직 디자인 등에서 멀티플렉서(multiplexer, MUX)란 소자를 접할 수 있는데, 이는 다수의 low-level 채널을 하나의 high-level 채널로 통합하는 역할을 한다. 그리하여 여러 input 중에서 하나를 선택하여 출력하곤 하는데, I/O 다중화도 비슷한 느낌으로 받아들일 수 있다. 폴링(polling), 셀렉팅(selecting) 등 다양한 방법이 있지만, 여기선 셀렉팅 위주로 설명할 것이다.

I/O 다중화 기술은 파일 식별자(file descriptor)를 관리하기 위해 이들을 배열로 만들어 그룹화한다. 이후 (`select` 시스템 콜 등을 통해) 커널에게 프로세스를 정지할 것을 요청한 다음, 특정 부분집합에서 I/O 이벤트(읽을 준비가 된 경우, 쓸 준비가 된 경우, 예외가 발생한 경우, 타임아웃된 경우 등)가 하나 이상 발생한 경우 해당 벡터 필드를 세팅하고 (애플리케이션으로) 리턴한다. 우리는 이러한 방식(파일 식별자 배열의 값을 검사하는 것)으로 그곳에 대해 서비스를 제공함으로써 여러 클라이언트와 상호작용 할 수 있다. 디테일은 책을 통해ㅎ

우선 I/O 다중화는 단일 프로세스의 컨텍스트에서 서버가 구동된다는 게 주 특징이다. 우리는 그로 인해

- 모든 logical control flow가 프로세스의 전체 주소공간에 접근할 수 있다.
- flow 간 데이터 공유가 원활하다.
- 디버깅이 타 동시성 프로그램에 비해 친숙하고 편리하다.
- context switching을 요구하지 않고, 그런 류의 제어에 의한 오버헤드가 발생하지 않는다.

하지만, 그럼에도 분명한 단점이 있는데,

- 코드가 타 동시성 프로그램에 비해 상당히 복잡하고 그 크기가 커진다.
- 멀티코어 프로세서의 장점을 잘 이끌어내기 어렵다.


# Thread-Based Concurrent Programming
스레드(thread) 기반의 동시성 프로그래밍은 멀티 프로세스 방식과 I/O 다중화의 특징이 약간씩 섞여있다. 우선, 스레드 기반 프로그래밍을 알아가기 전에 스레드에 대한 개념의 이해가 필요할 것이다.

## Thread
스레드는 프로세스 내에서 돌아가는 논리 흐름의 단위를 의미한다. 프로세스와 약간 비슷하면서도 (상당히) 다르다.

![](/imgs/csapp/102.png)

![](/imgs/csapp/103.png)

각각의 스레드는 스택과 레지스터, 조건 코드, 스택 포인터, PC 등을 포함하는 스레드 컨텍스트, 그리고 자신의 고유한 스레드 ID(TID) 등을 가진다. (지역 변수 저장 등을 위한 각 스레드의 스택은 타 스레드로부터 보호되지 않는다.) 간단한 경우엔 한 프로세스 당 하나의 스레드를 가지지만, 한 프로세스에 여러 스레드가 존재할 수도 있고, 그러한 스레드들은 해당 프로세스의 전체 가상 주소, 커널 컨텍스트, 코드 등을 공유한다. 

![](/imgs/csapp/104.png)

프로세스와 마찬가지로, 다수의 스레드는 동시적일 수 있다. 보통 두 스레드에 대해, 그 흐름들이 시간적으로 중첩되면 동시적(concurrent)이라고 한다. 그렇지 않으면, 순차적(sequential)이라고 한다.

![](/imgs/csapp/105.png)

스레드와 프로세스는 많은 측면에서 비슷하지만 그러면서도 몇 가지 중요한 차이점을 지닌다.

우선 어떤 프로세스와 연관된 스레드는 동료(peer) 스레드와 함께 풀(pool)의 형태를 이루나, 프로세스는 부모-자식에 의한 계층 구조를 가진다. 심지어 메인 스레드라 불리는 스레드조차도 그저 프로세스에서 돌아가는 첫 스레드라는 의미에서만 타 스레드와 구분될 뿐이다. 이럼으로써, 스레드는 서로 동일한 수준의 접근 또는 간섭을 하고, 동일한 고유 데이터에 접근할 수 있다. 자식 프로세스는 부모를 `wait`하지 못하고, 각자 독립된 데이터를 읽고 쓰는 걸 생각하면 그 차이가 드러난다.

가장 중요한 점은, 컨텍스트 전환, 생성 등과 같은 제어가 스레드에서 비용이 훨씬 적게 든다. 동일한 종류의 동작을 수행할 때 프로세스 쪽이 두 배 정도 더 많은 사이클을 돈다고 한다. 이러한 특징은 비슷한 방법인 멀티 프로세스보다 오버헤드를 적게 발생시킨다.

그럼 원래 내용으로 돌아가, 멀티 스레드 방식으로 동시성 서버를 구현하려면 어떻게 할까? (코딩은 간단하지 않겠지만) 답은 간단하다. 메인 스레드는 연결 요청을 listen하도록 하고, 각 클라이언트마다 동료 스레드를 할당해 각각의 클라이언트를 맡도록 하면 된다. 앞서 언급했듯, 각 스레드는 TID를 제외하고 모든 process state를 공유할 것이며, 지역 변수를 위한 독립적 스택을 지닐 것이다.

![](/imgs/csapp/106.png)

정리하면, 스레드 기반의 동시성 프로그래밍은 다음과 같은 특징을 지닌다.

- 스레드 간 데이터 공유가 용이하다.
- 프로세스 기반 방식보다 자원 관리 측면에서 효율 적이다.
- 다수의 스레드의 프로그램 변수의 공유는 의도치 않은 오류를 유발할 수 있다.
- (특정 데이터의 share/private의 설정과 같은) 설계가 어렵고, 디버깅도 타 방식에 비해 복잡하다.

책에는 C에서 사용할 수 있는 스레드 조작을 위한 표준 인터페이스인 Posix 스레드, 그리고 세마포어(semaphore)라는 공유 자원에 대한 접근을 제어하는 방법을 제공하는 변수에 대해 잘 설명되어있다. 시간 나면 읽어보자.


# 마치며
어차피 CS:APP는 개론이고, 이후 OS, Network, Computer Architecture 등에서 각각의 내용을 더 자세히 배울 것이다. High-level에서의 이해를 성공했다는 점에 만족하고 여기서 끝낸다. 야호!
