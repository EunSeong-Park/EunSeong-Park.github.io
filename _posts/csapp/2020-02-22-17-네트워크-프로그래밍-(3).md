---
layout: post
title:  "17 네트워크 프로그래밍 (3)"
date:   2020-02-22
author: Eunseong Park
categories: CS:APP
---

# Intro
네트워크 프로그래밍 파트의 마지막 포스팅이다. 이번엔 웹 서버에 관한 내용을 간단히 다룰 예정이다.


# Web Server
웹 서버는 HTTP(HyperText Transfer Protocol)라는 프로토콜을 기반으로, 클라이언트로부터 요청을 받아 HTML 문서나 각종 객체를 전송하는 서버를 의미한다. 이 또한 일반적인 클라이언트-서버 모델과 같이, 클라이언트(웹 브라우저 등)가 요청을 보내고, 그 요청을 받은 서버가 응답을 제공하는 방식이다.  

## Web Content
웹 서버는 클라이언트의 요청에 대응하여 컨텐츠(content)를 리턴하는데, 여기서 컨텐츠란 MINE(Multipurpose Internet Mail Extensions) 타입과 연관되는 바이트 시퀀스 파일을 의미한다. 아래 표는 MINE 타입의 예시를 나타낸다. (http://www.iana.org/assignments/media-types/media-types.xhtml 여기서 MINE 타입 리스트를 확인할 수 있다.)

MINE type | Description
---|---
`text/html` | HTML 문서
`text/plain` | 형식 없는(unformatted) 텍스트
`image/gif` | GIF 포맷으로 인코딩된 binary image
`image/png` | PNG 포맷으로 인코딩된 binary image

HTTP 응답(response)에 의해 리턴될 수 있는 컨텐츠는 static(정적)이거나 dynamic(동적)일 수 있다.

- Static content : 디스크 내 파일에 저장되어있는 파일
- Dynamic content : 서버에 의해 돌아가는 실행 파일에 의해 생성 또는 출력된 파일

## URL
그리고 종류에 무관하게, 웹 서버가 리턴하는 모든 내용은 서버과 관리하는 파일에 연관된다. 각 파일은 URL(Universal Resource Locator)이라는 고유한 이름을 가진다.

`http://www.cmu.edu:80/index.html`

위 URL을 보자. 클라이언트는 '/' 이전 까지의 내용(prefix)을 통해 프로토콜의 종류(http), 서버(`www.cmu.edu`), listening하는 포트(80, optional)를 지정한다. 그리고 '/' 이후의 내용(suffix)을 통해 어떤 종류의 컨텐츠(정적/동적)를 요청하는지, 파일 위치 등을 지정한다.

## HTTP Transaction
HTTP는 인터넷 연결 위로 전송된 텍스트 라인들을 기초로 하고 있어, Linux의 telnet 프로그램을 이용해 인터넷 상의 모든 웹 서버와의 트랜잭션을 수행할 수 있다.

![](/upload_image/92.png)

위 예시와 같이, telnet 실행 후 telnet은 우리가 텍스트를 입력할 것을 기다린다. 텍스트 입력 후 enter 키를 누르면 telnet은 그 줄을 읽고 거기에 `"\r\n"`(carriage return 및 line feed)를 추가하여 그 스트링을 서버로 보낸다. 이는 HTTP standard가 각 줄에 이들을 요구하기 때문이다.

이제 이러한 트랜잭션을 요청(request)과 응답(response), 두 관점에서 확인해보자.

### HTTP Request
HTTP 요청(request)은 요청 라인(request line)과 따라 나오는 0개 이상의 요청 헤더(request header), 그리고 헤더 리스트를 종료하기 위한 따라나오는 빈 텍스트 라인으로 이루어져 있다.

요청 라인은 아래와 같은 형식으로 구성된다.

    <method> <uri> <version>

`<method>`는 주어진 리소스에 대해 수행할 명령을 나타낸다. 

Method | Description
---|---
`GET` | 특정 리소스의 표시를 요청한다.
`HEAD` | 특정 리소스의 헤더 정보만을 요청한다. (without body)
`POST` | 서버에게 특정 정보나 파일을 서버로 전송한다.
`PUT` | `POST`와 유사하나 갱신 위주의 목적으로 사용한다.
`DELETE` | 웹 리소스를 제거한다.
`TRACE` | 요청 리소스가 수신되는 경로를 표시한다.
`OPTIONS` | 웹 서버에서 제공하는(가능한) method를 질의한다.

`<uri>`는 해당 요청의 URI(Uniform Resource Identifier)를 지정한다. 여기서 URI는 URL보다 조금 더 넓은 개념으로, 리소스를 나타내는 유일한 주소로 볼 수 있다. URL은 파일 이름 및 argument를 포함하는 URL의 suffix를 포함한다.

그리고 `<version>`은 해당 요청이 준수하는 HTTP 버전을 나타낸다.

요청 헤더는 아래와 같은 형식으로 구성된다.

    <header name>: <header data>
    
각 헤더는 개행(enter)에 의해 구분되며, 빈 텍스트 후 개행에 의해 그 끝이 지정된다. 헤더는 서버에게 요청에 대한 추가적인 정보를 제공한다. 위 예시에서는 `Host: www.aol.com`가 헤더에 해당된다.

### HTTP Response
HTTP 응답(response) 또한 HTTP 요청과 상당히 유사하다. HTTP 응답은 응답 라인(response line)과 따라오는 0개 이상의 요청 헤더(response header), 헤더를 종료하기 위한 빈 텍스트 라인, 그리고 컨텐츠가 따라온다.

응답 라인은 아래와 같은 형식을 지닌다.

    <version> <status code> <status msg>

`<version>`은 응답이 준수하는 HTTP 버전, `<status code>`는 정수로 나타내어 지는 상태, 그리고 `<status msg>`는 그에 해당하는 메세지를 나타낸다. 여러 종류가 있지만, 첫 번째 숫자에 의해 그 상태의 종류를 구분할 수 있다.

1XX | 2XX | 3XX | 4XX | 5XX
---|---|---|---|---
조건부 응답 | 성공 | 리다이렉션 완료 | 요청 오류 | 서버 오류

대표적인 예시는 아래와 같다.

Status code | Status msg | Description
---|---|---
100 | Continue | 서버가 요청을 받았으며 나머지 요청을 기다린다, 클라이언트는 요청을 계속 해야한다.
200 | OK | 요청이 성공적으로 처리되었다.
301 | Moved permanently | 컨텐츠가 새로운 위치로 영구적으로 이동했다.
400 | Bad request | 서버가 요청을 이해하지 못했다.
401 | Unauthorized | 해당 요청은 인증을 필요로 한다.
403 | Forbidden | 서버가 요청을 거부한다.
404 | Not found | 서버가 요청한 리소스를 찾을 수 없다.
505 | HTTP Version Not Supported | 서버가 요청에 해당하는 HTTP 프로토콜 버전을 지원하지 않는다.

더 자세한 건 인터넷을 찾아보자.

그리고 응답 헤더는 아래와 같은 형식을 가진다.

    <header name>: <header data>
    
요청 헤더에서와 비슷하게, 응답에 대한 부가적인 정보를 제공한다. 예를 들어 `Content_Type`은 응답의 body의 MINE 타입을 나타내고, `Content-Length`는 body의 컨텐츠 길이를 나타낸다.

## 동적 컨텐츠의 처리
우리는 컨텐츠를 클라이언트에게 보내는 과정을 컨텐츠를 처리한다(serve)고 표현한다. 같은 요청에 대해 항상 같은 응답을 보냄으로써 처리하는 정적 컨텐츠와 달리, 동적 컨텐츠는 그에 대한 변수가 상당히 많고 처리 과정도 다소 복잡하다. 이러한 동적 컨텐츠를 서버는 어떻게 처리할까?

우선 그 동적 컨텐츠의 처리 방식을 간단히 살펴보자.

![](/upload_image/93.png)

1. (Request) 클라이언트가 URI를 포함한 HTTP 요청을 서버에 보낸다.
2. (Create) 서버는 자식 프로세스를 생성하여 URI에 해당하는 실행 파일을 돌린다.
3. (Content to server) 프로그램은 동적 컨텐츠를 만들어 내고, 서버는 이를 가져온다.
4. (Content to clinet) 서버는 클라이언트에게 해당 컨텐츠를 전달한다.

각각의 과정이 어떻게 이루어지는지는 CGI(Common Gateway Interface)에 의해 설명될 수 있다. 동적 컨텐츠를 위한 프로그램들은 CGI spec에 따라 작성되는데, 그래서 이들을 CGI 프로그램이라고도 부른다. CGI는 이들에게 어느 정도의 정보 전달의 표준을 제공한다.

예시로, `http://add.com/cgi-bin/adder?15213&18213`와 같은 URI를 사용하는 요청을 생각해보자.

1. 클라이언트에서 서버로의 인자 전달
클라이언트는 프로그램에서 필요한 인자(argument)를 전달할 수 있어야 한다. 단, 클라이언트는 프로그램으로 바로 인자를 전달하지 못하고, 서버가 이를 받아서 프로그램에게 다시 보내야 한다. 앞서 보았듯, `?`에 의해 프로그램 이름과 인자 리스트가 구분되며, 각 인자는 `&`에 의해 구분된다. 위 예시에선 `adder`라는 CGI 프로그램을 `15213`, `18213` 인자를 받고 실행한다.

2. 서버에서 프로그램으로의 인자 전달
CGI 프로그램명과 인자를 전달받은 서버는 이를 CGI 프로그램에게 보내야 한다. fork된 이후 프로세스는 `execve`를 통해 프로그램을 실행하기 전, 환경 변수 `QUERY_STRING`을 설정하고(위 예시에선 `"15213&18213"`) 프로그램은 런타임에 `getenv` 함수를 통해 해당 값을 참조할 수 있다.

3. 컨텐츠 전달
프로그램이 서버로 컨텐츠를 전달하고 서버가 다시 클라이언트로 보내는 것처럼 보이지만, 실제로는 다르며 더욱 흥미롭다. CGI 프로그램에선 자신의 동적 컨텐츠를 표준 출력(`stdout`)으로 내보낸다. 서버는 CGI 프로그램 로드 및 실행 전에 `dup2` 함수를 호출하여 표준 출력을 클라이언트와 이어진 연결 식별자(connected socket)로 재지정한다. 이럼으로써 CGI 프로그램이 표준 출력을 통해 출력한 모든 내용이 클라이언트로 직접 가게 된다.


# More about HTTP
이제부터 HTTP에 대한 짜잘한 내용이다. 가볍게 알아보자.

## HTTP Version
HTTP는 0.9 버전(나중에 설정된 버전 번호다.)부터 문서화되어 꾸준히 확장 및 발전해왔다.

- HTML/0.9 : 요청은 단일 라인으로 구성되며 전송은 HTML 문서로만 가능했다.
- HTML/1.0 : 요청에 대한 상태가 응답에 나타남, HTML 문서 외의 파일도 전송 가능, 메서드 추가, HTML 버전 지정 등 다양한 기능이 추가되고 융통성이 향상되었다. 그러나 매 트랜잭션마다 새로이 연결을 만들어야 했다.
- HTML/1.1 : 연결이 재사용 가능해지며, 파이프라이닝 도입, 청크 인코딩, 캐싱 지원 등 다양한 기능이 추가되며, 이는 표준 프로토콜로 지정되었다.
- HTML/2 : 텍스트 프로토콜에서 벗어나 바이너리 프로토콜이 되었다. 병렬 요청 및 응답이 동일 연결에서 이루어질 수 있게 되었으며, 통신에서의 스트림에 weight를 부여하여 우선 순위를 결정하여 처리할 수 있게 되었다.

이후로도 많은 기능이 생기고 더욱 발전하고 있는데, 그걸 굳이 여기에 적을 필요는 없는 것 같다. 궁금하면 인터넷을 보자!

## Data Transfer Mechanisms
HTTP에서 데이터를 전송하기 위한 여러 방식이 있다.

- Standard : 컨텐츠의 길이를 포함한 총 길이를 명시하며 통째로 전달한다. 프로그램은 전체 내용을 버퍼할 수 있어햐 한다.
- Chunked : 컨텐츠를 블록 단위로 쪼개어 전송하며, 각 블록마다 그 크기(in byte, hex coded)를 명시한다.

청크 전송은 전체 메세지의 크기를 모르더라도 HTTP를 통해 데이터를 전송할 수 있으며, 실제 데이터 사이즈는 마지막 패킷(길이가 0인)에 도달할 때 결정된다.

![](/upload_image/94.png)


# Proxy

![](/upload_image/95.png)

프록시(proxy), 혹은 프록시 서버는 클라이언트와 서버 사이의 일종의 중개자(intermediary)다. 클라이언트에 대해선 서버와 같이 동작하며, 서버에 대해선 클라이언트와 같이 동작한다.

![](/upload_image/96.png)

프록시의 도입은 여러 측면에서 유용하다. 요청과 응답의 사이에서 많은 역할을 수행할 수 있기 때문이다. 프록시의 종류에 따라 그 기능의 종류도 다르지만, 대체로 다음과 같은 기능을 가지고 있다.

- 웹 캐싱 : 프록시는 원격 서버에 요청한 리소스들을 캐시해 클라이언트가 특정 리소스를 요청할 때 원격 서버로의 접속을 최소화한 채 서버 내 정보를 제공받을 수 있다. 
- 보안 : 잠재적인 위험을 지닌 컨텐츠를 필터링 및 제한하여 클라이언트의 보안을 향상시킬 수 있다.
- 로깅 : 특정 사이트 및 리소스에 대한 사용 기록을 로그로 남겨 분석할 수 있다.
- 익명화 : 클라이언트의 사용 기록을 익명화하여 의 IP를 남기지 않고 이용할 수 있다.

프록시 서버를 통해 어떤 사이트를 접속한다고 하자. 그러면 아래와 과정을 거쳐 접속하게 된다.

1. 사용자가 특정 도메인에 접속하기 위해 요청하면, 이 요청은 프록시 서버로 전달된다.
2. 프록시 서버는 접속할 페이지가 캐시되어있는지 확인한다.
3. 캐시된 상태가 아니라면 서버와 연결해 해당 페이지를 가져온다.
4. 가져온 후, 또는 이미 캐시되었다면 그 페이지가 최신 버전인지 서버로부터 체크한다.
5. 최신 버전이 아니면 갱신된 부분을 가져온다.
6. 프록시 서버는 사용자에게 요청한 페이지를 제공한다.

보통 프록시는 warning.or.kr을 뚫기 위한 도구 정도로만 알려져 있는데, 실제론 더욱 유용한 도구였던 셈이다.


# 마치며
드디어 네트워크 프로그래밍 파트가 끝났다. 다만 타이틀과 달리 프로그래밍을 하지 않은 게 미련이 조금 남는다. 그래도 나한텐 생소했던 네트워크와 웹 개념을 어느 정도 이해할 수 있게 되어 꽤 의미있었다. 다음은 이 책의 마지막 파트인 동시성(concurrent) 프로그래밍이다. 마지막까지 열심히 책을 읽어보자.


