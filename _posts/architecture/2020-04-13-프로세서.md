---
title: "프로세서의 설계"
tags: Computer-Architecture
toc: true
---

# Intro
우리는 앞서 MIPS 아키텍처에서의 명령어 구조와 사용법들을 간략하게 알아보았다. 이제, 이러한 명령어를 온전히, 그리고 효율적으로 실행시킬 수 있도록 하드웨어(프로세서)를 설계해야 한다.

MIPS ISA는 각 명령어의 기능 및 동작에 따라 몇 개의 카테고리로 분류할 수 있는데, 우리는 그 중 일부만을 동작시키는 프로세서를 생각할 것이다. 즉, 부동소수점 연산이나 곱셈, 나눗셈 등은 생각하지 않는다.

- 메모리 참조 명령어
- 일부 산술/논리 명령어
- 분기/점프 명령어

단순한 구조에서부터 시작하여, 점차 많은 명령어를 다루며 효율적으로 작동하도록 하나씩 쌓아 올려보자.


# Implementation Overview

![](/imgs/ca/ca20.png)

가장 간단하고 추상적인 형태로 MIPS 프로세서를 나타내었다. 명령어와 관계 없이, 모든 명령에 대해 다음과 같은 동작을 수행한다.

- 프로그램 카운터(PC)에 따른 명령어를 가져온다(fetch).
- 명령어에서 읽을 레지스터를 선택하여, 레지스터 하나 혹은 둘을 읽는다.

이후엔 메모리에 접근할 수도 있고, 그렇지 않을 수도 있으며, PC를 새로운 값으로 조정할 수도 있고, 그렇지 않을 수도 있다. 가령 `beq`는 메모리엔 접근하지 않지만 PC 값을 변경할 수 있고, `lw`는 메모리에 접근하는 과정을 수반하며, `add`는 메모리 접근이나 PC 변경 없이 산술 연산만을 수행한다.

이러한 아이디어를 반영하기 위해, 또, 보다 현실적인 구조가 되기 위해 우리는 일부 유닛은 선택적으로 작동하며, 연산에 쓰일 값도 선택 가능해야 한다. 그것은 멀티플렉서(multiplexer, MUX)와 제어 유닛에 의해 이루어질 수 있다.

![](/imgs/ca/ca21.png)

__제어 유닛은 오로지 명령어의 종류에 의존한다.__ 그렇기에 명령어가 인출된 시점에서 MUX에서 어느 값을 뽑을지, 어느 유닛이 어떤 기능을 할지 등을 모두 결정할 수 있다. 


# Datapath & Stages
이제 명령어가 어떤 경로를 따라 프로세서가 동작하는지 알아보자. 이후 파이프라이닝(pipelining)에 대해 쉽게 이해하기 위해, 명령어가 실행되는 과정을 크게 다섯 단계로 나누어 볼 것이다.

## Stages
### Instruction Fetch (IF)

![](/imgs/ca/ca22.png)

가장 먼저 명령어의 인출(fetch)이 이루어져야 한다. PC의 값을 통해, 그 주소에 있는 명령어를 명령어 메모리로부터 가져온다.

지금은 분기나 점프 등에 의해 PC가 변경되는 경우를 고려하지 않는다. 그렇다면, PC는 다음 명령어의 인출을 위해 ALU를 통해 PC를 (32비트 기준으로) 4만큼 증가시킬 것이다. 

### Instruction Decode (ID)
앞서, 모든 제어 유닛은 명령어의 종류에 의존한다고 언급하였다. 즉, 명령어가 인출된 시점에서 프로세서가 앞으로 할 일들을 결정할 수 있다.

![](/imgs/ca/ca23.png)

가령 일반적인 R-format 명령어라면 피연산자로 작용할 레지스터 두 개와 목적지로 작용할 레지스터 하나를 고를 것이다. 또, 이 글 맨 위의 그림을 보자. 수행하려는 연산의 종류에 따라 ALU가 무슨 기능을 할지도 결정해주어야 한다. 

메모리 참조 명령어라면 어떨까? 우린 명령어의 하위 16비트와 오프셋 레지스터가 주소를 지정함을 알고 있다. 하지만 주소는 32비트를 가지므로 이를 부호 확장(sign-extension)하고, 주소 결정을 위해 오프셋 레지스터를 읽어야 한다. 물론, (`sw` 같은) 적재 명령어라면 저장될 값에 대한 레지스터를 하나 더 읽게 된다.

아무튼 이 단계에서 거의 모든 제어를 결정하고, 읽을 레지스터가 있다면 여기서 읽어 다음 단계로 보낸다. 어떤 명령어가 어떻게 제어를 결정하는지는 조금 뒤에 알아보자.

### Execute Operation (EX)
이제 주어진 피연산자들을 통해 산술 및 논리 연산을 수행한다. 산술/논리 명령어가 아니더라도 일부 명령어는 ALU를 거쳐야 한다. 분기 명령어라면 0-check가 필요하고, 메모리 접근 명령어라면 오프셋 레지스터와 주소값을 더해주어야 하고, `slt`같은 명령어라면 비교 연산을 해주어야 한다.

특히, `beq` 등의 분기 명령어라면, `target * 4`의 주소를 PC에 입력해야 하는데, (별도의 유닛(adder)을 사용하여) 이 단계에서 계산해준다.

![](/imgs/ca/ca24.png)

### Memory Access (MEM) & Write Back (WB)
일부 메모리 접근 명령어(`sw`, `lw` 등)는 데이터 메모리에 접근한다. ALU의 연산 결과로 접근할 데이터 메모리의 위치를 결정하고, 거기에 데이터를 쓰거나, 데이터를 읽어 레지스터로의 쓰기를 수행한다.

![](/imgs/ca/ca25.png)

메모리를 접근했든 그렇지 않든, 레지스터로의 쓰기를 수반하는 명령어는 WB stage를 거친다. 목적지(dest) 레지스터에 저장할 값은 MUX에 의해 결정된다. MUX의 스위치는 명령어 해석 단계에서 정해졌을 것이다.

## Single Datapath
위의 일련의 과정들을 한 클럭 사이클 내에 실행한다고 가정하자. 즉, 파이프라이닝 등을 고려하지 않고, 어떤 자원도 두 번 이상 사용되지 않음을 가정한다. 여기선 점프 명령어를 생각하지 말자.

![](/imgs/ca/ca26.png)

파란 와이어와 ALU control은 ID 스테이지에서 모두 결정된다. 이를 반영하면, 

![](/imgs/ca/ca27.png)

31-26 필드는 `opcode`로, 명령어의 종류를 결정한다. 즉, 여기서 모든 제어가 결정되는 셈이다.

25-21, 20-16 필드는 피연산자 레지스터의 번호를 결정한다. 레지스터로의 쓰기 작업이 있는 명령어라면 20-16 혹은 15-11 필드 중 하나가 목적지 레지스터가 된다. 예를 들어, `lw`같은 명령어는 전자가 쓰이고, 일반적인 산술/논리 연산은 후자가 쓰인다. 그래서 "Write register" 앞에 MUX로 둘 중 하나를 생략한다.

15-0 필드는 상수가 들어온다. 이는 주소 연산에 사용될 수도, `addi`와 같은 상수를 포함하는 산술/논리 연산에 사용될 수도 있다. 혹은, 여기서 일부를 뽑아내어 `funct`나 `shamt`로 사용할 수도 있다. (`shamt`)는 여기선 생략되었다.

보면 알겠지만 겹치는 부분이 좀 있다. 또, 어떤 명령어는 어떤 필드의 데이터를 필요로 하지 않거나, 같은 필드를 다른 명령어와 다른 의미로 해석하여 사용할 수도 있다. 하지만 그럼에도 별 문제는 되지 않는데, 제어 유닛으로 주어진 필드를 적절히 해석하기 때문이다.

그리고, ALUOp 부분의 와이어는 약간 두꺼운데, 이는 단일 비트가 통과하는 와이어가 아님을 표현하기 위함이다. ALU가 수행할 수 있어야 하는 연산 종류가 다양하다는 점을 생각하면 당연한 일이다.

### Example
> 위의 데이터패스(datapath)에서, ALUOp를 제외하여 7개의 제어를 위한 와이어를 확인할 수 있다. 또, 당연하게도, 이들은 명령어의 종류에 따라 완전히 결정된다. R-format 명령어, `lw`, `sw`, `beq` 명령어에 대한 진리표(truth table)를 작성해보자.

- `RegDst`: 레지스터에 대해 쓰기를 수행한다면, 목적지 레지스터는 15-11 필드인가(1), 20-16 필드인가(0)?
- `ALUSrc`: ALU에서 immediate를 피연산자로 사용하는가(1), 레지스터 값을 피연산자로 사용하는가?
- `MemtoReg`: 레지스터에 대해 쓰기를 수행한다면, 데이터를 메모리로부터 가져오는가?
- `RegWrite`: 레지스터에 대해 쓰기를 수행하는가?
- `MemRead`: 메모리로부터 읽기를 수행하는가?
- `MemWrite`: 메모리에 대해 쓰기를 수행하는가?
- `Branch`: 분기 명령어인가?

Instruction | `RegDst` | `ALUSrc` | `MemtoReg` | `RegWrite` | `MemRead` | `MemWrite` | `Branch`
---|---|---|---|---|---|---|---
R-format | 1 | 0 | 0 | 1 | 0 | 0 | 0 
`lw` | 0 | 1 | 1 | 1 | 1 | 0 | 0 
`sw` | X | 1 | X | 0 | 0 | 1 | 0
`beq` | X | 0 | X | 0 | 0 | 0 | 1

X는 don't care condition이다. 말 그대로 0이든 1이든 상관없는 셈이다. 예를 들어, `sw`의 RegDst는 결과에 어떤 영향도 미치지 않는다. `RegWrite`가 꺼져있기 때문에, 목적지가 어떻게 되든 쓰기가 수행되지 않기 때문이다.

디지털 로직 및 디자인을 배웠으면 알겠지만, 실제 회로 설계에서 유리한(보다 간단하게 설계할 수 있는) 걸 선택하면 된다. 


# Pipelining
이 단원의 가장 중요한 파트다. 간단히 설명하면, __파이프라이닝(pipelining)은 여러 명령어를 중첩시켜 실행시키는 기술이다.__

## Intro
파이프라이닝의 필요성을 알기 위해, 위에서 다룬, 단일 사이클에 모든 과정이 처리되는 구조의 문제점을 생각해보자. 단일 사이클의 경우, 모든 명령어는 같은 길이(즉, 가장 긴 명령어의 길이)를 가지게 된다. (캐시가 없는) 메모리 접근은 일반적인 명령어에 비해 수 백 배의 시간이 걸린다는 점을 생각해보면 이는 명백히 비효율성을 낳는다.

예시를 하나 들어본다.

> 만두를 빚기 위해선 크게 세 과정이 필요하다. 반죽으로부터 만두피를 만들고(1), 만두피에 소를 넣고 잘 빚은 다음(2), 찜통에 넣는다(3). 

한 요리사가 일련의 과정을 하나하나 진행하는 건 파이프라이닝되지 않은 경우다. 만약 요리사가 3번 과정을 막 끝냈다면, 찌지 않은, 완성된 만두가 없으므로 2번 과정을 먼저 수행해야 한다. 하지만 그러려면 만두피가 필요하므로, 또 미리 만들어놓은 만두피가 없으므로, 1번 과정을 먼저 수행해야 한다. 1-2-3 순서의 과정을 계속 반복해야 한다.

하지만 동료를 불러 이를 파이프라이닝할 수 있다. 요리사 3명이 1, 2, 3번 과정을 하나씩 맡아 계속 수행하는 것이다. 그렇다면 각 과정은 쉬지 않고 계속 진행되므로 (처음을 제외하면) 3배로 만두를 만드는 속도가 빨라진다.

"요리사를 더 동원한다"는 건 어찌 보면 자연스럽지 않을 수도 있다. 하지만 파이프라이닝되지 않은 과정은 (멀티코어와 같은) 추가적인 자원을 활용할 수 없으므로 어느 정도 의미가 일치한다고 볼 수 있다.

Time |1|2|3|4|5|6|
---|---|---|---|---|---|---
Step 1|O|\_|\_|O|\_|\_
Step 2|\_|O|\_|\_|O|\_
Step 3|\_|\_|O|\_|\_|O

Time |1|2|3|4|5|6|
---|---|---|---|---|---|---
Step 1|O|O|O|O|O|O
Step 2|\_|O|O|O|O|O
Step 3|\_|\_|O|O|O|O

이처럼 확연한 성능 차이가 드러난다.

### Example
우리는 위에서 다섯 단계로 명령어 실행 과정을 알아보았는데, 이 또한 파이프라이닝될 수 있다. 

![](/imgs/ca/ca28.png)

> 이와 같은 패턴으로 파이프라이닝이 충분히 오래 진행된다면, 파이프라이닝은 몇 배의 성능 향상을 가져다 주는가?

파이프라이닝되지 않은 경우, 한 명령어를 실행하기 위해 800ps가 소요되지만, 파이프라이닝된 경우 (처음을 제외하면) 200ps가 소요된다. 처음의 지연은 파이프라이닝이 충분히 진행된다면 무시할 수 있는 수준이 된다. 즉, 4배의 성능 향상을 가져다 준다.

## MIPS
MIPS와 그것의 ISA는 파이프라이닝을 위해 설계되었다고 봐도 과언이 아니다. 그 이유는...

1. 모든 명령어가 같은 길이(여기선 32비트로 생각한다)를 가져, 명령어 인출 및 해석 과정이 자연스럽고 간단하게 이루어진다. x86 같은 가변 길이를 가지는 ISA는 파이프라이닝이 굉장히 복잡해진다.
2. R-format, I-format 등으로 분류할 수 있을 정도로 통일되고 적은 종류의 명령어 형식을 가지고 있으며, 다른 형식 사이에서도 어느 정도 통일된 양식을 공유한다(e.g. 레지스터 번호 필드). 이로 인해, 우리는 `opcode`를 뜯어 명령어를 확인한 다음 레지스터를 읽는 대신, `opcode`를 뜯고, 다른 필드를 뜯어 레지스터를 읽고, immmediate 등을 보내는 작업을 한 스테이지에 할 수 있다. 전자의 경우 스테이지 내의 의존성으로 인해 두 스테이지로 분리되어야 할 것이다.
3. 메모리 피연산자는 오직 적재/저장 명령어에서만 나타난다. 이는 EX 스테이지 이전에 메모리를 읽을 필요가 없으며, 별도의 확장이 필요 없음을 의미한다.

이처럼 MIPS는 파이프라이닝에 대한 부가적이고 지엽적인 문제를 고려하지 않도록 해준다. 이것이 MIPS로 파이프라이닝을 배우는 이유다.

파이프라이닝은 고수준의 성능 향상을 가져다주는 깔끔하고 정교한 기술이다. 지금까지는....

## Hazards
해저드(hazard)는 파이프라이닝의 가장 큰 걸림돌이자, 현실이다. 그리고 파이프라이닝을 온전히 사용하기 위해선 해저드를 반드시 잘 처리해주어야 한다. 이제 해저드를 처리하기 위해 조금씩 프로세서 설계를 복잡하게 만들 것이다... 그런데 해저드가 뭐냐?

해저드(hazard)란, __다음 명령어가 바로 다음 사이클에 실행될 수 없는 상황__ 을 의미한다. 어째서 해저드가 발생할까?

### Structural Hazard
구조적 해저드(structural hazard)는 그 원인이 하드웨어나 구조에 있는 경우를 의미한다. 예를 들어, 데이터 메모리와 명령어 메모리가 동시적으로 접근할 수 없다면, 명령어 인출과 메모리 접근 단계가 동시에 진행될 수 없어 해저드가 발생할 것이다.

하지만 MIPS ISA는 구조적 해저드를 잘 피할 수 있도록 설계되었다. 파이프라이닝 설계가 더욱 용이해진 셈이다.

### Data Hazard
데이터 해저드(data hazard)는 어떤 명령어가 다른 명령어나 데이터에 의존적이어서, 이를 기다려야 하는 경우를 의미한다. 예를 들어,

```assembly
add  $s0,  $t0,  $t1
sub  $t2,  $s0,  $t3
```
