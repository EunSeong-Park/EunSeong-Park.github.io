---
title: "명령어 & MIPS"
tags: Computer-Architecture
toc: true
---

# Intro
명령어(instruction)는 컴퓨터, 즉 하드웨어가 이해할 수 있는 명령의 단위다. 그리고 특정 아키텍처가 이해할 수 있는 명령어들의 집합을 명령어 집합(instruction set)이라 한다. 일반적인 프로그래밍 언어에 비해 낮은 수준(low-level)의 개념인데, 명령어가 하드웨어에 어떻게 작용하고, 어떻게 하드웨어를 고려하여 설계되는지를 이해하는 것은, 컴퓨터 아키텍처를 이해하는 데 큰 도움이 된다.

여기선 MIPS(Microprocessor without Interlocked Pipeline Stages) 아키텍처를 중심으로 알아볼 것이다. 


# MIPS
MIPS는 CPU 아키텍처(architecture)의 일종으로, 조금 있으면 알겠지만 MIPS의 명령어 체계는 굉장히 깔끔하고 통일된 형식을 가지고 있다. 간단한 교육용 MIPS 시뮬레이터로 [EduMIPS64](https://github.com/lupino3/edumips64/releases/download/v1.2.6/edumips64-1.2.6-standalone.jar)가 있다. 매뉴얼은 [여기](https://github.com/lupino3/edumips64/releases/download/v1.2.6/edumips64-1.2.6-en.pdf)에 있다. (나중에 배울) 파이프라이닝 진행 과정을 비롯해 레지스터, 메모리 값의 변화도 쉽게 확인할 수 있다.

## Operands
### Register Operand
대부분의 명령어는 레지스터를 피연산자(operand)로 지정한다. MIPS는 32 비트 크기의 레지스터 32개를 가진다. 0번부터 31번까지 있으며, 이들은 각자의 용도가 있다. 프로시저 호출의 인자(argument)로 사용하는 레지스터가 있는가 하면, 리턴 값으로, 혹은 리턴 주소로 사용하는 레지스터 또한 있다. 물론 이들은 완전히 강제되는 것은 아니고, 일종의 약속이다. 당연히 지키는 게 좋다.

보통 `$(number)`나, `r(number)`, `R(number)`와 같이 레지스터를 표기한다. `$3`과 `r3`은 같은 레지스터를 가리킨다. 또, 이들의 용도를 잘 구분하기 위한 일종의 별명이 있다.

![](/imgs/ca/ca44.png)

`HI-LO`, `PC`, `EPC`는 특수한 목적의 레지스터이므로 여기선 생각하지 않는다. 또, 0번 레지스터는 반드시 0의 값만을 가지는, 덮어쓰기가 불가능한 레지스터다. 

알다시피 레지스터는 메모리 계층 구조의 상단에 위치해있다. 메인 메모리보다 빠르고, 그만큼 용량이 적다. 우리는 메모리 적재 및 저장의 비용을 피하고, 가능한 한 레지스터를 사용해 데이터를 저장해야 한다. 

#### Register Convention
레지스터 각각의 용도에 맞게 사용하는 것도 중요하지만, 프로시저 호출 시에도 지켜야 할 규약이 있다. 프로시저 호출 시, 레지스터 값은 백업되어야 한다. "누가 그 값을 백업해야 하는가?"가 문제다.

Caller-saved 레지스터의 경우, 프로시저 호출 전 (호출 후에도 본인이 써야 하는) 레지스터 값을 스택 등에 저장해놓고, 호출한 프로시저가 리턴하면 저장한 레지스터 값을 복구하는 방식으로 백업된다.

Callee-saved 레지스터의 경우, 호출된 함수가 그 레지스터를 사용하기 전 미리 백업해놓고, 리턴 직전에 이를 복구해놓는다.

대부분은 caller-saved다. 하지만 `$s0(16)-$s7(23)`과 스택 포인터 `$sp(29)`, 프레임 포인터 `$gp(30)` 등은 피호출자가 백업을 해야 하는 callee-saved 레지스터다.

### Memory Operand
메모리는 구조체, 배열 등의 크고 복잡한 데이터를 저장하는 데 용이하다. 왜냐? 용량이 크기 때문이다. 하지만 앞서 말했듯, 접근에는 오랜 시간이 걸려, 가능한 한 레지스터에서 주요 연산을 수행하는 게 좋다.

메모리는 byte-addressed 방식이다. 즉, 각각 주소는 각각의 메모리 바이트에 대응된다. 하지만 그와 동시에 word-aligned 방식이므로, 주소는 반드시 4의 배수여야 한다. 이러한 규칙으로 인해, 임의의 주소와 길이를 지정하는 대신, 우리는 워드 단위로 주소를 지정하고, 그것의 전체를 읽거나, 절반, 혹은 한 바이트를 읽는다. 이는 불편해 보일 수도 있지만, 실제론 그것의 구조와 동작 방식을 깔끔하게 만들어준다.

또, MIPS는 big-endian이다. 즉, MSB가 가장 낮은 주소값을 가진다. 

마지막으로, 이들은 산술/논리 연산에서 직접 가져와질 수 없다. 산술 및 논리 연산을 위해선, 메모리에서 레지스터로 값을 가져오고, 레지스터 간 연산을 수행한 다음, 다시 적재하는 과정이 필요하다. 이 또한 명령어 수행 방식을 깔끔하게 하기 위한 제약이다.

### Immediate Operand
물론 상수 또한 피연산자로 작용할 수 있다. 하지만 모든 명령어에 사용 가능한 것은 아니고, 특정 명령어에만 사용할 수 있다. 메모리나 PC에 관한 명령어나, `i` 접두어가 붙은 명령어들이 그에 해당된다.

별도의 접두, 접미어가 필요하지 않으며, 음수 또한 사용할 수 있다.

## Instructions
아래와 같은 주요 명령어들이 있다. CS:APP에서 어셈블리를 사용해보았다면 꽤 익숙할 것이다. 이들을 쭉 훑어보면서 어떤 문법을 가지는지 확인해보자.

![](/imgs/ca/ca43.png)


# MIPS Assembly Translation
이제부터 일반적인 C 언어로 작성된 코드 일부를 MIPS 어셈블리로 번역하며 명령어들을 익혀볼 것이다.

## Arith/Logic Operation
가장 간단한 산술 및 논리 연산을 번역해보자.

```
int a, b, c, d, e, f;

a = b + c;
d = a - e;
e = f;
c -= 1;
```

알파벳 순서에 따라 `$t0`부터 `$t5`까지 사용하자.
```
add  $t0, $t1, $t2
sub  $t3, $t1, $t4
add  $t0, $t5, $zero
addi $t2, $t2, -1
```
여기서 주목할 만한 점이 조금 있다. 우선, Intel x86-64 어셈블리와 달리, `mov` 명령어가 없다. 그래서 보통 `add`에 피연산자 하나를 `$zero`로 사용해 `mov`와 같은 효과를 내는 게 일반적이다. 또, `subi`같은 명령어는 존재하지 않는다. `addi`에 음수를 더해줌으로써 같은 효과를 만들어내자.

### Pseudoinstruction
사실 `move`라는 의사 명령어(pseudoinstruction)가 존재하긴 한다. 하지만 이는 실제 명령어는 아니고, 어셈블러가 그러한 기능을 하도록 적절히 실제 명령어로 바꿔줄 뿐이다. 이러한 명령어 종류가 몇 있는데, 굳이 따로 살펴볼 필요는 없어 보인다.

## Conditional Operation
조건에 따라 다른 결과를 낳는 명령어들이 있다. 분기(branch) 명령어와 조건부 세팅 명령어가 바로 그것인데, 하나하나 알아보도록 하자.

분기(branch) 명령어는 두 레지스터 값이 같거나(`beq`) 다르면(`bne`) 목적지 주소로 분기한다. 목적지 주소의 계산과 결정은 이후에 점프 명령어와 함께 알아볼 것이다.

### Branch Instruction
분기 명령어의 목적지는 라벨링(labeling)을 통해서도 설정 가능하다. 예를 들어,
```
Main:
      bne  $s3, $s4, Else
      add  $s0, $s1, $s2
      j    Exit
Else: sub  $s0, $s1, $s2
Exit: ...
      ...
```
이러면 어셈블러는 목적지 레이블을 적절한 주소로 치환해준다. 이는 어셈블리 프로그래밍을 굉장히 편하게 만들어준다.

분기 명령어를 사용해 `for`나 `while` 루프를 구현할 수 있다.
```
Loop: ...
      ...
      bne/beq  .., .., Loop
      j        Exit
Exit: ...
```

### Set Instruction
조건부 세팅 명령어(적절한 번역이 떠오르지 않는다)는 두 값을 비교하여, 참일 경우 목적지 레지스터에 1을, 거짓일 경우 0을 세팅하는 명령어다. (같은지 다른지만 비교하는) 분기 명령어와 연계하여, 분기를 조금 더 다양한 조건으로 시도할 수 있다. 

예를 들어, 아래와 같은 명령어는 `$s1`이 `$s2`보다 작으면 분기하도록 한다.

```
slt  $t0, $s1, $s2
bne  $t0, $zero, Label
```

이러한 방식은 다소 복잡해보이지만, 실제론 아키텍처를 잘 고려한 명령어 설계의 일부다. $\ge$, $\le$는 $=$이나 $\ne$보다 비용이 비싼 연산이다. 예를 들어 그러한 비싼 연산을 사용하는 `blt`같은 명령어가 존재한다면, 그것의 처리를 위해 더 느린 클럭이 필요하다. (가장 느린 명령어에 맞춰질 것이므로) 즉, 모든 명령어들이 손해를 보게 되는 것이다.

사실 `blt`와 같은 명령어를 사용할 수 있다. 하지만 이는 실제 명령어는 아닌 pseudoinstruction으로, `slt`와 `bne`로 적절히 번역된다.

## Procedure Call
프로시저, 함수의 호출은 어느 곳에서나 다 비슷하게 작동한다. 

1. 인수와 리턴 주소를 적절한 위치에 저장한다.
2. 프로시저로 제어를 넘긴다.
3. 프로시저를 위한 공간을 할당한다.
4. 프로시저를 수행한다.
5. 리턴 값을 적절한 위치에 저장한다.
6. 프로시저를 호출한 리턴 주소로 제어를 다시 넘긴다.

MIPS 명령어 집합에선, `jal`과 `jr`이 프로시저 호출의 핵심 명령어다. 

`jal ProcedureLabel`은 자신의 다음 명령어 주소(PC+4)를 `$ra` 레지스터에 집어넣고 주어진 주소로 점프한다. 리턴 주소를 저장해놓고 점프하는, jump-and-link 명령어다.

`jr (Reg)`는 레지스터 값(주로 `$ra`를 쓴다)을 PC에 대입하여 해당 주소로 제어를 넘긴다. jump-on-register여서 `jr`이다. 

즉, 우리는 `jal Label`로 `Label`부터 시작하는 프로시저로 제어가 넘어가고(그러면서 리턴 주소를 저장한다), 프로시저 내의 명령어를 수행한 후 `jr` 명령어를 통해 `jal` 다음의 명령어로 리턴한다.

### Stack
스택은 메인 메모리의 일부로, (대부분의 스택이 그렇듯) 높은 주소에서 낮은 주소 방향으로 데이터를 쌓는다. 스택의 끝은 `$sp(R29)`에 의해 포인팅되어, 스택에 푸시하고 싶다면 스택 포인터 레지스터를 낮추면서 저장하고, 팝하고 싶다면 스택 포인터를 높이면 된다.

```
addi  $sp, $sp, -4   # 한 워드만큼의 스택 공간 할당 
sw    $s0, 0($sp)    # $s0에 저장된 워드를 스택에 푸시
...
...
lw    $s1, 0($sp)    # 스택에 저장된 워드를 $s1에 꺼내옴.
addi  $sp, $sp, 4    # 스택 공간 할당 해제.
```

### Calling Convention
Caller-saved 레지스터의 경우, 프로시저 호출자는 호출한 프로시저가 자신이 이후에 사용할 데이터를 해치지 않도록 해야 한다. 예를 들어, 리턴 주소(`$ra`)를 따로 백업하지 않았고, 호출한 프로시저가 다른 프로시저를 `jal`로 호출했다면 리턴 주소는 덮어씌워질 것이다.

이러한 상황을 막기 위해, 호출자는 몇 개의 레지스터 값을 스택에 저장한다. 프로시저 호출 전 레지스터 값을 백업하고, 프로시저가 리턴한다면 이를 다시 스택으로부터 꺼내와 사용하면 된다. 이 때, 스택 포인터 레지스터(`$sp`)는 callee-saved이기 때문에 덮어씌워질 걱정은 하지 않아도 된다.

### Example
재귀(recursion)의 대표적인 예시인, 팩토리얼(factorial) 함수를 구현해보자.

```cpp
int fact (int n){
	if (n < 1) return 1;
	else return n * fact(n-1);
}
```

```
fact:
      addi  $sp, $sp, -8   	# 스택에 두 워드 공간 할당
      sw 	$ra, 4($sp)    	# 리턴 주소 저장
      sw    $a0, 0($sp)    	# 인자 저장

      slti  $to, $ao, 1		
      beq   $t0, $zero, L1  # n >= 1이면 L1으로 분기

      # n < 1인 경우 (base case)
      addi	$v0, $zero, 1	# 리턴($v0) 값을 1로 설정
      addi	$sp, $sp, 8		# 스택 할당 해제.

      jr 	$ra 			# 리턴.

  L1: addi	$a0, $a0, -1    # n = n-1
      jal   fact   			# 함수 호출

      lw 	$a0, 0($sp)		# n 복구.
      lw    $ra, 4($sp)     # 리턴 주소 복구.
      addi 	$sp, $sp, 8 	# 스택 할당 해제.

      mul   $v0, $a0, $v0   # fact(n) = n * fact(n-1)

      jr    $ra 			# 리턴.
```

