---
title: "명령어 & MIPS"
tags: Computer-Architecture
toc: true
---

# Intro
명령어(instruction)는 컴퓨터, 즉 하드웨어가 이해할 수 있는 명령의 단위다. 그리고 특정 아키텍처가 이해할 수 있는 명령어들의 집합을 명령어 집합(instruction set)이라 한다. 일반적인 프로그래밍 언어에 비해 낮은 수준(low-level)의 개념인데, 명령어가 하드웨어에 어떻게 작용하고, 어떻게 하드웨어를 고려하여 설계되는지를 이해하는 것은, 컴퓨터 아키텍처를 이해하는 데 큰 도움이 된다.

여기선 MIPS(Microprocessor without Interlocked Pipeline Stages) 아키텍처를 중심으로 알아볼 것이다. 


# MIPS
MIPS는 CPU 아키텍처(architecture)의 일종으로, 조금 있으면 알겠지만 MIPS의 명령어 체계는 굉장히 깔끔하고 통일된 형식을 가지고 있다. 간단한 교육용 MIPS 시뮬레이터로 [EduMIPS64](https://github.com/lupino3/edumips64/releases/download/v1.2.6/edumips64-1.2.6-standalone.jar)가 있다. 매뉴얼은 [여기](https://github.com/lupino3/edumips64/releases/download/v1.2.6/edumips64-1.2.6-en.pdf)에 있다. (나중에 배울) 파이프라이닝 진행 과정을 비롯해 레지스터, 메모리 값의 변화도 쉽게 확인할 수 있다.

## Operands
### Register Operand
대부분의 명령어는 레지스터를 피연산자(operand)로 지정한다. MIPS는 32 비트 크기의 레지스터 32개를 가진다. 0번부터 31번까지 있으며, 이들은 각자의 용도가 있다. 프로시저 호출의 인자(argument)로 사용하는 레지스터가 있는가 하면, 리턴 값으로, 혹은 리턴 주소로 사용하는 레지스터 또한 있다. 물론 이들은 완전히 강제되는 것은 아니고, 일종의 약속이다. 당연히 지키는 게 좋다.

보통 `$(number)`나, `r(number)`, `R(number)`와 같이 레지스터를 표기한다. `$3`과 `r3`은 같은 레지스터를 가리킨다. 또, 이들의 용도를 잘 구분하기 위한 일종의 별명이 있다.

![](/imgs/ca/ca44.png)

`HI-LO`, `PC`, `EPC`는 특수한 목적의 레지스터이므로 여기선 생각하지 않는다. 또, 0번 레지스터는 반드시 0의 값만을 가지는, 덮어쓰기가 불가능한 레지스터다. 

알다시피 레지스터는 메모리 계층 구조의 상단에 위치해있다. 메인 메모리보다 빠르고, 그만큼 용량이 적다. 우리는 메모리 적재 및 저장의 비용을 피하고, 가능한 한 레지스터를 사용해 데이터를 저장해야 한다. 

#### Register Convention
레지스터 각각의 용도에 맞게 사용하는 것도 중요하지만, 프로시저 호출 시에도 지켜야 할 규약이 있다. 프로시저 호출 시, 레지스터 값은 백업되어야 한다. "누가 그 값을 백업해야 하는가?"가 문제다.

Caller-saved 레지스터의 경우, 프로시저 호출 전 (호출 후에도 본인이 써야 하는) 레지스터 값을 스택 등에 저장해놓고, 호출한 프로시저가 리턴하면 저장한 레지스터 값을 복구하는 방식으로 백업된다.

Callee-saved 레지스터의 경우, 호출된 함수가 그 레지스터를 사용하기 전 미리 백업해놓고, 리턴 직전에 이를 복구해놓는다.

대부분은 caller-saved다. 하지만 `$s0(16)-$s7(23)`과 스택 포인터 `$sp(29)`, 프레임 포인터 `$gp(30)` 등은 피호출자가 백업을 해야 하는 callee-saved 레지스터다.

### Memory Operand
메모리는 구조체, 배열 등의 크고 복잡한 데이터를 저장하는 데 용이하다. 왜냐? 용량이 크기 때문이다. 하지만 앞서 말했듯, 접근에는 오랜 시간이 걸려, 가능한 한 레지스터에서 주요 연산을 수행하는 게 좋다.

메모리는 byte-addressed 방식이다. 즉, 각각 주소는 각각의 메모리 바이트에 대응된다. 하지만 그와 동시에 word-aligned 방식이므로, 주소는 반드시 4의 배수여야 한다. 이러한 규칙으로 인해, 임의의 주소와 길이를 지정하는 대신, 우리는 워드 단위로 주소를 지정하고, 그것의 전체를 읽거나, 절반, 혹은 한 바이트를 읽는다. 이는 불편해 보일 수도 있지만, 실제론 그것의 구조와 동작 방식을 깔끔하게 만들어준다.

또, MIPS는 big-endian이다. 즉, MSB가 가장 낮은 주소값을 가진다. 

마지막으로, 이들은 산술/논리 연산에서 직접 가져와질 수 없다. 산술 및 논리 연산을 위해선, 메모리에서 레지스터로 값을 가져오고, 레지스터 간 연산을 수행한 다음, 다시 적재하는 과정이 필요하다. 이 또한 명령어 수행 방식을 깔끔하게 하기 위한 제약이다.

### Immediate Operand
물론 상수 또한 피연산자로 작용할 수 있다. 하지만 모든 명령어에 사용 가능한 것은 아니고, 특정 명령어에만 사용할 수 있다. 메모리나 PC에 관한 명령어나, `i` 접두어가 붙은 명령어들이 그에 해당된다.

별도의 접두, 접미어가 필요하지 않으며, 음수 또한 사용할 수 있다.

## Instructions
아래와 같은 주요 명령어들이 있다. CS:APP에서 어셈블리를 사용해보았다면 꽤 익숙할 것이다. 이들을 쭉 훑어보면서 어떤 문법을 가지는지 확인해보자.

![](/imgs/ca/ca43.png)

이제부터 일반적인 C 언어로 작성된 코드 일부를 MIPS 어셈블리로 번역하며 명령어들을 익혀볼 것이다.


# MIPS Assembly Translation
## Arith/Logic Operation
가장 간단한 산술 및 논리 연산을 번역해보자.
```C
int a, b, c, d, e, f;

a = b + c;
d = a - e;
e = f;
c -= 1;
```
알파벳 순서에 따라 `$t0`부터 `$t5`까지 사용하자.
```
add  $t0, $t1, $t2
sub  $t3, $t1, $t4
add  $t0, $t5, $zero
addi $t2, $t2, -1
```
여기서 주목할 만한 점이 조금 있다. 우선, Intel x86-64 어셈블리와 달리, `mov` 명령어가 없다. 그래서 보통 `add`에 피연산자 하나를 `$zero`로 사용해 `mov`와 같은 효과를 내는 게 일반적이다. 또, `subi`같은 명령어는 존재하지 않는다. `addi`에 음수를 더해줌으로써 같은 효과를 만들어내자.

### Pseudoinstruction
사실 `move`라는 의사 명령어(pseudoinstruction)가 존재하긴 한다. 하지만 이는 실제 명령어는 아니고, 어셈블러가 그러한 기능을 하도록 적절히 실제 명령어로 바꿔줄 뿐이다. 이러한 명령어 종류가 몇 있는데, 굳이 따로 살펴볼 필요는 없어 보인다.

## Conditional Operation
조건에 따라 다른 결과를 낳는 명령어들이 있다. 분기(branch) 명령어와 조건부 세팅 명령어가 바로 그것인데, 하나하나 알아보도록 하자.

### Branch
분기 명령어는 두 레지스터 값이 같거나(`beq`) 다르면(`bne`) 목적지 주소로 분기한다. 목적지 주소의 계산과 결정은 이후에 점프 명령어와 함께 알아볼 것이다.
