---
title: "[OM 7] Queuing Theory"
tags: Management-Engineering OM
toc: true
---

# Intro
큐(queue)는 이름이 참 귀여운 것 같다. 그나저나 한 음절짜리 단어인데 알파벳을 다섯 개나 먹는 걸 생각하면 여러 복잡한 생각이 든다.

아무튼, 오늘은 큐, 즉 대기열에 대해 알아볼 예정이다. 보통 대부분의 서비스는 사람이 몰리면 대기열이 형성될 수밖에 없다. 대기열은 "보통은" 없을 수록 좋다. 마스크 사려고 약국 앞에서 줄을 서는 것도, 몇 백 평짜리 매장에서 키오스크가 두 개 밖에 없을 때도, 기다림은 고객의 불만족으로 이어진다. 그리고 이러한 불만족은 공급자에게도 분명한 손실로 다가온다.

또, 고객뿐 아니라, 노동자나 기계가 작업을 대기하는 경우도 있다. 공정을 잘못 설계하면 그러한 시간 낭비가 존재할 수 있는데, 이 또한 생산성을 저하시키고 불필요한 비용을 발생시킬 수 있다.

이러한 대기열은 무엇에 의해 만들어지는가? 대기열로 인해 어떤 현상이 발생하는가? 그리고 이걸 어떻게 최소화하는가? ...가 이번에 알아볼 내용이다. 수학적/확률적 분석을 통해 최적의 프로세스와 서비스 구조를 만들 수 있도록 해보자.


# Queueing Theory
일반적인, 그리고 간단한 대기열 모델은 아래와 같이  나타내어질 수 있다. S는 서비스 제공자, 즉 서버(server), C는 고객들을 의미한다. 

![](/imgs/mge/om28.png)

앞서 말했듯, 대기열과 그로 인한 시간의 손실은 어느 곳에나 존재한다.

- 서비스를 기다리는 손님
- 화물의 상/하차를 기다리는 배나 비행기
- 자재가 들어올 때까지 대기하는 공장 설비

대기는 대부분의 경우 명백한 시간 손실이지만, 필연적으로 존재할 수밖에 없는 경우가 있다.

- 대기열을 완전히 없애기 위해 서버를 늘리면 비용이 너무 크게 발생한다. 또, 상대적으로 대기열이 적거나 없는 시간엔 서버의 낭비가 발생한다.
- 서비스나 절차에 내재된 필연적인 지연 및 대기가 존재한다.

대기열 이론(queuing theory)은 대기열로 인한 손실과 서비스 채널의 증가로 인한 비용 사이의 적절한 합의점을 찾는 것을 도와준다.

![](/imgs/mge/om29.png)

## Notations
본격적으로 들어가기 전에 몇 가지 노테이션을 정리하고 가자.

- State of system: 대기열 시스템 내의 고객(customer)의 수
- Queue length: 서비스를 기다리는 고객의 수, 이는 state of system에서 서비스를 받고 있는 고객의 수로도 구할 수 있다.
- $N(t)$: 어떤 시점 $t$에서 대기열 시스템 내의 고객 수
- $P_n(t)$: 정확히 $n$명의 고객이 어떤 시점 $t$에서 대기열 시스템 내에 있을 확률
- $s$: 서버(server), 즉 parallel service channel의 수
- $\lambda_n$: mean arrival rate. 즉, $n$명의 고객이 시스템 내에 있을 때, 단위 시간당 새 고객이 들어오는 비율
- $\mu_n$: mean service rate. $n$명의 고객이 시스템 내에 있을 때, 단위 시간당 서비스 처리율, 서비스 처리 시간은 이것의 역수다.

우리는 쉬운 논의를 위해, steady-state, 즉 시간에 구애받지 않는 시스템을 가정한다. Steady-state에선 다음과 같은 노테이션을 사용할 수 있다.

- $P_n$: $P_n(t)$와 같다.
- $L$: 대기열 시스템 내의 고객 수의 기댓값(expectation)
- $L_q$: 대기열 길이(queue length)의 기댓값
- $W$: 고객 각각의 대기 시간의 평균. 서비스 자체의 시간을 포함한다.
- $W_q$: 고객 각각의 대기 시간의 평균. 서비스 자체의 시간은 제외한다.

## Queuing Model
대기열 모델은 __M/M/s__ 와 같이 표현될 수 있다. 각 글자가 의미하는 바는 다음과 같다.

- 1st: distribution of interarrival time
- 2nd: distribution of service time
- 3rd: number of server

또, distribution은 다음과 같이 나타낸다.

- $M$: exponential distribution
- $D$: degenerate distribution (constant times)
- $E_k$: Erlang distribution
- $G$: general distribution (any arbitrary distribution allowed)

참고로, 분포들은 대충 이렇게 생겼다. [출처](https://blog.cloudera.com/)

![](/imgs/mge/om30.png)

## Performance Measure
우리는 주어진 시스템이 어느 정도의 성능을 가지는지에 관심이 있다. 원래는 다 유도해볼 생각이었는데, 과정을 보고 흥미가 딱 떨어져서 그만 뒀다. 인터넷 세상에 정리된 게 많으니 그거 보고 이해하자...

### Little's Law
Stable한 시스템에서, 시스템 전체나 대기열 내의 고객 수 평균은 다음과 같이 구할 수 있다.

$L = \lambda W$

$L_q = \lambda W_q$ 

$W = W_q + \frac{1}{\mu}$

즉, 대기열이나 시스템의 평균 대기 시간에 평균 arrival rate를 곱한 셈이다.

### Birth-and-Death Process
Birth-and-Death process는 Markov process의 일종으로, state를 1 올리는 birth, 1 줄이는 death. 이 두 종류의 state transition만이 존재하는 프로세스다.

![](/imgs/mge/om31.png)

시스템 내의 고객 수는 이러한 프로세스로 표현할 수 있다. 개인의 birth(대기열로의 진입)와 death(서비스 제공 완료)는 무작위로 발생함을 가정하자.

### M/M/1 Queueing System
우리는 arrival rate가 푸아송 분포를 따르며, 그에 따라 interarrival time이 exponential distribution을 따른다고 가정한다. (왜 그런지는 통계를 복습하면 알 수 있다.)

또, 병렬 서비스 채널은 하나이며, 대기열의 허용 길이나 전체 고객 수는 생각하지 않는다.

$\lambda, \mu, s$가 주어진 경우, utilization factor, $\rho = \frac{\lambda}{\mu}$와 $P_n$을 구하고, 이후 $L, W$를 구하면 된다. 

![](/imgs/mge/om32.png)

### M/M/s Queueing System
병렬 서비스 채널(서버)이 여러 개라면 어떨까? 당연히 성능이야 좋아지겠다만, 우리는 정확한 정도를 알고 싶다.

사실 난 별로 알고 싶지 않고, 유도는 더욱 하기 싫다.

![](/imgs/mge/om33.png)

## Application
뭐, 우리가 고객 분포를 어찌할 수는 없고, 이렇게 얻을 수 있는 정보는 "서비스를 얼마나 병렬적으로 제공하는 게 최선인가?"에 대한 답이다. 즉, 서버의 수를 결정하기 위해 대기열 이론을 사용할 수 있다.

물론, 현실은 조금 더 복잡하다. 간단한 예로 은행을 생각해보자. 은행 특유의 고객 분포에 대한 정보가 필요하고, 고객마다 받고자 하는 서비스(대출 문의는 단순 입출금보다 오래 걸릴 것이다)의 분포, 직원의 상황(모든 직원이 모든 종류의 업무를 수행할 수 없다면? 해당 서비스가 가능한 직원을 대기해야 할 것이다) 등 고려해야 할 것이 너무 많다. 대기열 모델은 굉장히 복잡해질 것이다.

물론, 서버의 수를 결정하는 것이 시스템 최적화의 유일한 방법은 아니다. 서버 각각의 코스트를 줄이는 방법(키오스크 등의 사용)도 있고, 서비스나 프로세스의 구조를 변경하거나 새로운 도구의 도입으로 고객의 분포를 유리한 방향으로 바꿀 수도 있다.

# 마치며
굉장히 대충 정리한 기분이다. 사실 기분 탓이 아니라 정말 그렇다. 이게 다 메인 전공이 아니라 그렇다...



