---
title:  "[Networking 4] 애플리케이션 계층 (3)"
toc: true
tags: Networking
---

# Intro
이 계층은 대체 언제쯤 끝날까..? 눈물이 난다. 아무튼 이메일과 DNS에 대해 잠깐 짚고 넘어가자.

# E-mail
모두가 알겠지만, 이메일(e-mail)은 electronic mail을 의미한다. 읽고 보냄에 시간적 제약이 없는 비동기적인 통신 매체고  

이메일엔 중요한 세 요소가 있다. 유저 에이전트(user agent), 메일 서버, 그리고 이러한 과정을 규정하는 프로토콜인 SMTP(Simple Mail Transfer Protocol)이다. 

- User agent : Outlook과 같은 메일 클라이언트를 의미한다. 이들은 메일을 작성/수정/조회하는 데 사용된다. 
- Mail server : 수신 메일을 보관하고(in mailbox), 송신 메일을 관리한다(in message queue). 또, 메일 서버 간 SMTP 프로토콜을 이용해 메세지를 전달한다.

## SMTP
SMTP는 reliable한 이메일 전송을 위해 TCP를 사용한다. 송신자의 메일 서버에서 수신자의 메일 서버로 메세지를 '직접' 보내주는 역할을 한다. (즉, 중개 서버를 거치지 않는다) 이해를 위해 메일을 보내는 과정을 생각해보자.

1. 송신자는 수신자의 메일 주소, 메세지 내용을 포함하여 유저 에이전트에게 제공한 뒤, 메세지를 보내도록 한다.
2. 유저 에이전트는 메세지를 해당 유저의 메일 서버로 보낸다. 이 때, 메세지는 메세지 큐에 올라간다.
3. 송신자의 메일 서버의 SMTP(클라이언트)는 수신자의 SMTP 서버에게 TCP 연결을 설정한다.
4. SMTP의 핸드셰이킹 후, 클라이언트는 메세지를 TCP 연결로 전송한다.
5. SMTP 서버는 메세지를 수신하고, 수신자의 서버는 메세지를 수신자의 메일 박스에 놓는다.
6. 이후 수신자는 유저 에이전트를 이용해 메세지를 원하는 시점에 읽을 수 있다.

이제 SMTP를 HTTP와 비교해보자. 두 프로토콜 모두 어떤 호스트에서 다른 호스트로 파일 등을 전송하는 데 사용된다. 하지만 몇 가지 중요한 차이점이 있는데,

HTTP | SMTP
---|---
사용자가 서버로부터 정보를 가져오기 위해 HTTP를 사용한다. (pull) | 어떤 사용자가 다른 사용자에게 메세지를 보내기 위해 SMTP를 사용한다. (push)
전송 데이터의 형식에 관한 제한이 없다. | 헤더와 바디 모두 7-bit ASCII 포맷을 지켜야 한다.
응답 메세지에 각각의 객체를 캡슐화(encapsulation)하여 전송한다. | 모든 메세지의 객체를 한 메세지로 만든다.


## Mail Access Protocols
SMTP는 메세지 송신에서 중추적인 역할을 한다. 하지만 수신자가 메세지를 읽을 때는 이야기가 조금 다르다. 위에서 언급했듯, SMTP는 push 방식이기 때문에, 수신자는 메세지의 획득을 위해 SMTP를 사용할 수 없다. 따라서, 메일에 액세스하기 위한 프로토콜이 필요한데, 여기엔 POP3, IMAP 등이 있다.

- POP3(Post Office Protocol ver3) : 아주 간단한 메일 접속 프로토콜(mail access protocol)이며, 에이전드와 메일 서버 사이의 세션이 시간 동안만 상태 정보를 유지한다(stateless across session). 
- IMAP(Internet Mail Access Protocol) : POP3보다 더 많은 기능을 가지지만, 그만큼 더 복잡하다. 폴더 생성, 이동, 할당 및 메세지의 일부 구성요소를 받는 기능 등을 제공한다.

## Web-Based E-mail
gmail이나 Hotmail 같은 메일 서비스는 web-based interface를 제공한다. 즉, 사용자는 일반적인 웹 브라우저를 통해 메일 서비스를 이용하는 것이다. 사용자는 HTTP를 통해 메일 서버에 있는 메일 박스와 통신할 수 있는 것이다. 다만, 메일 서버 사이에선 여전히 SMTP를 사용해 메세지를 전달한다.


# DNS
사람을 이름, 주민등록번호 등으로 식별할 수 있듯이, 인터넷 호스트도 그러한 수단을 필요로 하며, 다양한 종류를 가지고 있다.

naver.com과 같은 호스트 네임(host name)은 우리에게 친숙하고 기억하기 쉽다. 하지만 호스트 네임은 그 자체로 호스트 위치에 대한 정보를 거의 제공하지 않으며, 가변 길이의 알파뉴메릭(alphanumeric)으로 구성되어 있어, 그것의 처리에 어려움이 있다. 

그러한 점에서, IP 주소는 호스트를 식별하고 정보를 처리하기에 유리할 것이다. 우선 고정된 크기와 범위를 가지며(32-bit), 계층화된 주소로 호스트가 어느 네트워크에 위치하는지 등에 대한 정보를 알 수 있기 때문이다. 즉, 라우터 등은 호스트 네임을 사용하는 것보다 IP 주소를 사용하는 걸 더 선호할 것이다.

이러한 차이를 해소하기 위해, IP 주소와 호스트 네임 사이를 매핑(mapping)하는 서비스인, DNS(Domain Name System)다. DNS는 DNS 서버들의 계층 구조로 구현된 분산 데이터베이스(distributed database)고, 호스트가 주소/네임 해석을 위해 요청하도록 허락하는 애플리케이션 계층 프로토콜이다. DNS는 이런 IP address-host name 간 매핑 외에도 아래와 같은 기능을 제공한다.

- Aliasing : 어떤 호스트 네임은 하나 이상의 별명(alias)을 가질 수 있다. 즉, 같은 호스트를 지정하는 여러 호스트 네임이 있는 것인데, DNS는 alias에 대한 원래의 호스트 네임을 얻기 위해 사용될 수 있다. 메일 서버에서도 비슷한 맥락에서 aliasing을 제공한다. 
- Load Distribution : 중복된 웹 서버(replicated Web server)는 하나의 호스트 네임에 대해 수 많은 IP 주소가 존재한다. DNS는 이와 같은 중복 서버 사이에서 부하를 분산하기 위해, 호스트 네임에 대한 IP 주소를 회전시켜 트래픽을 분산토록 해준다.

## Structure
앞서 언급 했듯, DNS의 서비스는 분산 계층 데이터베이스에 의해 이루어진다. 어떠한 단일 DNS 서버도 모든 호스트에 대한 매핑을 갖지 않으며, 특정 방식에 따라 계층화되어 전세계에 걸쳐 분산되어 있다. 그것은 중앙 집중(centralized) 방식이 가지는 문제 때문인데,

- Single point of failure : 서버가 고장나면 전체 인터넷이 작동하지 않는다.
- Traffic volume : 하나의 서버가 모든 DNS 질의를 처리해야 한다.
- Distance : 어떤 클라이언트는 중앙 서버로부터 굉장히 멀리 떨어져있을 수 있다.
- Maintenance : 모든 호스트에 대한 정보를 하나의 서버가 가지고 있어야 하며, 그만큼 자주 갱신해야 한다.

분산형 데이터베이스는 상기된 문제를 어느 정도 해결해주며, 무엇보다도 중앙 집중형에 비해 확장성이 좋다.

DNS 서버는 앞서 말했듯 '계층' 분산 데이터베이스로 이루어진다. 이들을 root DNS 서버, TLD(Top-Level Domain) DNS 서버, authoritative DNS 서버로 구분해 볼 수 있다.

- Root : 인터넷엔 다수의 루트 DNS 서버가 있어, 이들은 보안 및 신뢰를 위해 복사된 서버들의 클러스터다. 이들은 `.com`, `.org` 등의 일반 최상위 도메인이나 `.kr`, `.jp` 등과 같은 국가 코드 최상위 도메인을 모두 포함한다.
- TLD : 위에서 언급된 최상위 도메인 서버에 대한 책임이 있다.
- Authoritative : 기관은 각자의 DNS 서버 및 레코드를 가진다. 그리고 이는 기관이나 그것의 서비스 제공자에 의해 유지 및 관리될 수 있다.

또, DNS의 다른 형태로, 로컬 DNS 서버가 있다. 이는 앞의 것처럼 엄격하게 계층을 이루진 않지만 DNS 구조의 중심에 있는데, 가정, 회사 ISP 같은 것들은 로컬 DNS 서버(or default name server)를 가진다. 호스트가 DNS 질의(query)를 보내면, 쿼리는 이를 (프록시처럼 동작하는) 로컬 DNS 서버로 보내며, 로컬 DNS 서버는 이를 DNS 서버 계층으로 전달할 것이다. 이러한 과정은 크게 두 가지로 볼 수 있다.

반복적 질의(iterative query)는 호스트가 로컬 DNS에게 IP를 요청하면, 로컬 DNS가 각 계층의 서버에게 쿼리를 보냄으로써 IP를 받는다. 반면, 재귀적 질의(recursive query)는 로컬 DNS가 root에게, roo는 TLD에게, TLD가 authoritative에게 사슬 구조로 쿼리를 보낸다. 첫 그림은 반복적, 두 번째 그림은 재귀적 쿼리를 나타낸다.

![](/imgs/network/net12.png)

![](/imgs/network/net13.png)

## DNS Caching
DNS는 성능 향상과 쿼리를 줄이기 위해 캐싱 개념을 사용한다. 쿼리 사슬에서, DNS 서버가 호스트 네임-IP 매핑에 대한 정보를 응답으로 받았으면, 서버는 이를 로컬 메모리에 저장하여, 이후 같은 요청에 대해 바로 응답을 제공할 수 있을 것이다. 다만, 이러한 매핑과 호스트는 영구적이지 않기 때문에 적절한 주기로 해당 정보를 삭제한다.

또한, 로컬 DNS 서버는 TLD 서버의 IP 주소를 저장함으로써, 쿼리 사슬에서 루트 DNS 서버를 우회해 갈 수도 있다.

## DNS Records
DNS의 분산 데이터베이스는 RR(Resource Record)이라는 매핑을 위한 정보를 저장한다. 이는 `(Name, Value, Type, TTL)`과 같은 튜플(tuple) 형식으로 구성된다. `TTL`은 RR이 캐시에서 제거되는 시간을 지정한다. `Name`과 `Value`가 의미하는 바는 `Type`에 의해 결정된다.

Type | Name | Value
---|---|---
A | 호스트 네임 | 매핑되는 IP
NS | 도메인 | 도메인에 대한 매핑 정보를 가진 authoritative DNS 서버의 호스트 네임
CNAME | 별칭 호스트 네임(alias) | 정식 호스트 네임(canonical)
MX | 메일 서버의 별칭 호스트 네임 | 메일 서버의 정식 호스트 네임

## DNS Message
DNS 메세지는 질의(query) 또는 응답(reply) 메세지다. 이들은 공통적인 메세지 포맷을 가진다.

![](/imgs/network/net14.png)

상단의 6개의 필드로 구성된 12바이트 영역은 헤더 영역이다. Identification은 쿼리를 식별하기 위한 16비트의 숫자로, 이는 응답 메세지에 복사되어 질의와 응답 간의 일치를 식별토록 한다. Flag는 질의/응답 여부, 재귀 여부 등을 결정하는 다수의 플래그를 포함한다. 나머지 네 개의 필드는 헤더 다음(데이터 영역)에 오는 네 개의 타입의 발생 횟수를 나타낸다.

헤더 영역 아래에 있는 데이터 영역은, 질문, 답변, 책임, 추가 정보, 이렇게 4개의 필드로 나누어 볼 수 있다.

- Questions : 질의에 대한 정보를 나타낸다. 질의되는 이름, 질문 타입 등을 포함한다.
- Answers : 질의된 이름에 대한 자원 레코드(RR)를 포함한다. 한 호스트에 여러 IP가 매핑될 수 있기 때문에, RR도 다수일 수 있다.
- Authority : 다른 authoritative 서버의 레코드를 포함한다.
- Additional info : 추가적인 정보 및 레코드를 포함한다.

## Record Insertion
앞서 레코드가 DNS 데이터베이스로부터 어떻게 추출되는지에 주목했는데, 반대로 레코드를 어떻게 데이터베이스에 넣는지도 간단히 알아보도록 하자.

예를 들어, 새로이 창업을 하는 등의 이유로 새로운 도메인을 필요로 할 수도 있을 것이다. 그렇다면, 도메인 네임과 함께, 주(primary)책임 서버와 부(secondary)책임 서버, 그리고 IP 주소를 등록기관(DNS registrar)에 제공해야 한다. 등록기관은 이를 바탕으로 도메인 네임의 유일성을 판단하고, 그 도메인 네임을 DNS 데이터베이스에 넣는다.

등록하려는 도메인이 `networkutopia.com`, 주, 부 책임 서버가 각각 `dns1.networkutopia.com`, `dns2.networkutopia.com`이고, IP 주소가 `212.212.212.1`이라면, 등록기관은 두 RR을 `.com` TLD 서버에 저장할 것이다.

    (networkutopia.com, dns1.networkutopia.com, NS)
    (dns1.networkutopia.com, 212.212.212.1, A)

... 그리고 약간의 서비스 비용을 받을 것이다.

## Attacking DNS
DNS는 인터넷 구조에서 중추적인 역할을 하는 매우 중요한 요소다. 만약에 그러한 DNS가 공격당한다면 많은 인터넷 애플리케이션 및 사용자들에게 큰 피해를 끼칠 것이다. 몇 가지만 간단히 알아보자.

- DDoS : 공격자는 다량의 패킷을 DNS 서버로 보냄으로써, 정상적인 DNS 쿼리가 응답을 받을 수 없도록 한다.
- man-in-middle attack : 호스트로부터 쿼리를 가로채 가짜 응답을 리턴하는 공격 방식이다.
- DNS poisoning : DNS 서버로 가짜 응답을 보내, 그 서버가 가짜 레코드를 받아들이도록 한다. 웹 사이트를 유도하는 등으로 악용될 수 있다.







