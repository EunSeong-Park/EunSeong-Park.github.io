---
title:  "[Networking 11] 네트워크 계층 (1)"
toc: true
tags: Networking
---

# Intro
이제 다음 계층으로 넘어왔다. 바로 네트워크 계층(network layer)이다! 뭐를 배울지 간략하게 적어보고 싶은데, 배운 게 없어서 못적겠다... 천천히 알아보자.


# Network Layer Overview
네트워크 계층(network layer)은 세그먼트를 송신 호스트에서 수신 호스트(host)로 보내는 역할을 한다. 송신 측에선 세그먼트를 데이터그램(datagram)으로 캡슐화하고, 수신 측에선 세그먼트를 트랜스포트 계층으로 보낸다. 라우터는 IP 데이터그램의 헤더 필드를 조사하고 통과시키는데, 네트워크 계층 프로토콜은  모든 호스트뿐 아니라, 모든 라우터에도 존재함을 기억하자. 

네트워크 계층엔 크게 두 주요 기능이 존재한다. 

- Forwarding: 패킷을 적절한 경로의 출력 링크로 전달한다.
- Routing: 송신자가 패킷을 전송할 때, 네트워크 계층에선 패킷의 경로를 결정한다. 이러한 계산 알고리즘을 라우팅 알고리즘(routing algorithm)이라고 한다.

또, 네트워크 계층을 두 계층으로 나누어볼 수 있다.

- Data plane: 포워딩을 수행하는 계층
- Control plane: 라우팅을 수행하는 계층

물론 이는 많이 러프한 설명이고, 이들에 대한 디테일을 알아야 한다.

## Network Service Model
네트워크 서비스 모델은, 송/수신 측 사이의 패킷 전송의 특성을 설명한다. 네트워크 계층은 다음과 같은 서비스들을 제공할 수 있다. 실제 제공 여부는 서비스 모델에 따라 다르다.

- 무손실: 패킷이 목적지에 반드시 도달함을 보장한다.
- 제한 지연 내 무손실 전달: 무손실 보장에 더해, 일정 시간 내에 패킷을 전달한다.
- 순서화(in-order): 패킷들은 송신된 순서로 수신된다.
- 대역폭(bandwidth): 특정 대역폭을 지정하여, 그 이하의 속도로 전송된 모든 패킷은 손실 없이 특정 지연 이내에 도착한다.
- 지터(jitter): 두 개의 패킷 전송 간 시간 차가 같은 패킷에 대한 패킷 수신의 시간 차가 같거나 비슷하도록 보장한다.
- 보안(security): 데이터그램의 암호화 및 복호화를 보장한다.

대표적인 서비스 모델로는 다음과 같은 게 있다.

![](/imgs/network/net53.png)


# Router Architecture
라우터의 구조를 간단히 알아보자.

![](/imgs/network/net54.png)

상단이 control plane, 하단이 data plane이다. 라우팅 프로세서에서 라우팅 프로토콜(routing protocol)을 수행하고, 포워딩을 위한 포워딩 테이블(forwarding table)을 관리 및 계산한다. 하단은 크게 라우터 입력 포트와 스위칭 구조(switching fabric), 그리고 라우터 출력 포트로 구성된다. 각 포트는 보통 여러 개 존재한다.

## Input Port

![](/imgs/network/net55.png)

입력 포트는 위와 같은 구조를 가진다. Line termination과 link layer protocol은 각 계층(물리, 링크)을 구현한다. 큐에 있는 패킷들은 각자의 헤더와 포워딩 테이블에 의해 분석되어, 출력 포트가 확인되면 패킷은 스위칭 구조로 전송된다.

그럼 포워딩은 어떻게 수행되느냐?

- Destination-based forwarding: 전통적인 방법으로, 목적지 IP 주소에만 의존하여 포워딩할 위치를 결정한다.
- Generalized forwarding: 헤더 필드의 값들을 조사함으로써 포워딩할 위치를 결정한다.

### Destination-Based Forwarding
32비트 IP 주소를 생각해보자. 모든 가능한 목적지 IP와 링크 인터페이스(link interface) 사이의 매핑을 포워딩 테이블에 저장하면 $2^32$개의 엔트리가 필요할 것이다. 물론 이는 현실적으로 불가능하다.

우리는 그래서 최장 프리픽스 대응 규칙(longest prefix matching rule)을 사용한다. 우리가 원하는 대응이 결정되도록 하는 가장 긴 길이의 프리픽스를 저장하면, 엔트리 수를 많이 절약할 수 있다.

![](/imgs/network/net56.png)

예를 들어, `11001000 00010111 00011000 10100010`은 1번 링크로, `11001000 00010111 00011001 10100010`은 2번 링크로 이동할 것이다. 물론 이 방법을 사용하는 건 테이블 엔트리의 절약 외에도 더 중요한 이유가 있다. 이건 나중에 알아보자.

### Input Port Queuing
스위칭 구조에서의 전달이 입력보다 늦다면, 즉, 다수의 포트로부터 끊임없이, 그리고 동시다발적으로 패킷이 오면 입력 포트에서의 큐잉이 발생할 것이다. 조금 더 자세히 알아보자.

HOL(Head-Of-the-Line) blocking이란, 큐에 올라온 가장 앞의 데이터그램이 (출력 링크에서의 경쟁이 없음에도 불구하고) 큐 내의 다른 데이터그램의 포워딩을 막는 현상을 의미한다. 

![](/imgs/network/net58.png)

위의 그림에서는, 초록색 패킷은 그에 맞는 출력포트가 놀고 있음에도, 앞의 패킷이 막고 있기 때문에 HOL 블로킹을 겪게 된다. 이러한 현상은 큐 길이의 증가를 야기하는데, 이것의 해결책도 나중에 알아보도록 하자.

## Switching Fabric
스위칭 구조(switching fabric)를 통해 (목적지가 결정된) 패킷이 입력 포트에서 적절한 출력 포트로 이동한다. 전달을 위한 세 가지 방법이 있다.

- Memory: 프로세서에 의해, 패킷은 메모리를 거쳐 출력 포트로 전달된다. 
- Bus: 프로세서의 간섭 없이, 패킷을 공유 버스의 출력 포트로 전달한다. 버스 위엔 하나의 패킷이 전송될 수 있어, 버스 전달 속도가 스위칭 속도의 제한 요인이 될 수 있다.
- Interconnection: 크로스바(crossbar)와 같은 구조로 패킷을 출력 포트로 빠르게 전달한다. 패킷의 동시 전송이 가능하다.

![](/imgs/network/net57.png)

## Output Port

![](/imgs/network/net59.png)

만약 스위칭 구조가 포트로 보내는 속도가 전송 속도보다 빨라 디큐잉보다 큐잉이 많이 이루어진다면, 버퍼링(buffering)을 해주어야 한다. 그렇지 않으면 패킷 손실이 발생할 수 있기 때문이다.

![](/imgs/network/net60.png)

버퍼링의 정도는 $N$개의 flow와 $C$의 link capacity에 대하여, $\frac{RTT * C}{\sqrt{N}}$ 정도의 버퍼링을 권장한다.

패킷 스케줄러(packet scheduler)는 이러한 상황에서 어떤 패킷을 링크에 보낼지 결정한다. 이는 다음 절에서 설명한다.

## Scheduling Mechanisms
네트워크 계층에서의 스케줄링은, 링크에 보낼 다음 패킷을 고르는 행위를 의미한다. 적절한 스케줄링 알고리즘은 성능 향상을 가져다 줄 것이다.

### FIFO
가장 일반적인 방법은 FIFO 방식이다. 즉, 큐에 넣고 선착순으로 빼서 보내는 방법이다.

![](/imgs/network/net61.png)

만약 큐가 꽉 찼다면, 이를 버릴 방법(discard policy)을 생각해야 한다.

- Tail drop: 방금 도착한 패킷을 버린다.
- Priority: 우선 순위를 기반으로 버릴 패킷을 결정한다.
- Random: 무작위로 버린다.

### Priority Scheduling
각 패킷에 우선순위(priority)를 할당하여, 그 우선순위에 따라 패킷을 보낸다. 우선순위를 적용하는 만큼, 노화(aging)과 같은 다른 부가적인 기법을 적용할 수도 있다.

![](/imgs/network/net62.png)

### Round Robin(RR)
여러 클래스들에 대해 순환적으로 하나씩 패킷을 보낸다. 

![](/imgs/network/net63.png)

### Weighted Fair Queuing(WFQ)
RR 방식의 일반화된 버전이다. 각 클래스는 각 사이클에 대한 할당량을 받아, 그에 맞추어 패킷을 전송한다.

![](/imgs/network/net64.png)

