---
title:  "[Networking 1] 인터넷"
toc: true
tags: Networking
---

# Intro
인터넷(Internet)은 가장 보편적이고 거대한 규모의 글로벌 네트워크다. 이 책에서는 인터넷이라는 특정 네트워크를 중심으로 네트워크의 구성 요소 및 원리를 알아볼 예정이라고 한다. 인터넷에 관한 전반적인 정보를 아주 넓고 얇게 알아갈 예정인데, 단순히 overview 느낌이라 그냥 생각 없이 막 정리해나갈 생각이다.


# Internet
## 기본 구성 요소
대표적인 구성 요소들로 나누어 보자. 자세히 설명은 안하고 무엇무엇이 있다~ 정도만 보면 될 것 같다.

- End system(=host) : 인터넷에 연결되는 장치다. 
- Communication link : 구리선, 광케이블, 위성 등을 포함한 physical media로 구성되는 요소다. 이들은 특정한 전송률(transmission rate, bandwidth)을 이용해 데이터를 전송한다.
- Packet switch : 도착하는 패킷을 받아, 목적지로 패킷을 전달한다. 주로 라우터(router)와 링크 계층 스위치(link-layer switch)가 사용된다.

그리고 이렇게 디바이스, 라우터, 링크 등이 조직적으로 모이고 관리되는 집합체를 네트워크라 한다.

그리고 이들 간의 통신은 프로토콜(protocol)에 의해 제어되고, 수행된다. 프로토콜은 인터넷 상의 거의 모든 과정에 존재하여, 프로토콜은 인터넷에서 가장 중요한 자리를 차지하고 있다. 그래서 각각의 프로토콜들이, 그리고 모든 프로토콜이 수행해야 할 일을 합의하기 위해 인터넷 표준(Internet standards)이 만들어졌다.

## 인터넷과 서비스
인터넷을 애플리케이션에게 서비스를 제공하는 인프라 구조로서 바라볼 수도 있다. 인터넷은 특정 상황 및 서비스에 대해, 데이터를 보낼 때 필요한 사항, 또는 방법을 명시하는 API(Application Programming Interface)를 가지고 있어, 인터넷은 API에서 명시된 규칙을 따라 데이터를 전달한다.

책의 표현을 빌리면 이는 우편 서비스와 비슷한데, 편지를 보내주기 위해 우편 서비스는 발신인으로 하여금 우표를 붙이고, 보내는 사람 / 받는 사람의 정보를 기입하며, 지정된 우체통이나 창구에 넣도록 요구한다. 그리고 그렇게 접수된 우편을 그들의 방식과 방법을 따라 수신인에게 편지를 보내준다. 인터넷과 우편 서비스를 동일시해서 보면 공통점이 여럿 보인다.


# Internet Structure
인터넷의 구조를 이번엔 영역 별로 살펴보자. 

## Network Edge
PC, 모바일 기기, 서버 등을 포함한 end system은 직관적으로 네트워크의 가장자리에 있는 것처럼 보이고, 실제로 그렇다. 서버는 느낌 상 중추적인 역할을 하는 인상을 줘서, 코어에 있을 것 같지만 혼동하지 말자.

## Access Network
접속 네트워크(access network)란, 어떤 end system을 다른 먼 거리의 end system 까지의 경로가 있을 때, 그 경로 상 첫번 째 라우터에 연결하는 네트워크를 의미한다. 

## Physical Media
일반적인 전선이든, 광케이블이든, 혹은 전파든 어떤 연결이든 그 대상은 물리적인 무언가에 의해 연결되어 있다. 통신 종류나 연결 대상에 따라 그 매체는 달라질 수 있으며, 연결에서의 전송률, 단독 사용 여부(dedicated/shared) 등으로도 그 종류가 구분될 수 있다.

## Network Core
Interconnected router의 망으로 볼 수 있다. 딱히 할 말이 없다.


# Data Transmission
대표적인 데이터 전송 방식으론 패킷 교환(packet switching)과 회선 교환(circuit switching)이 있다. 패킷 교환이 더 널리 사용되는 걸로 알고 있지만, 아무튼 둘 다 알아보고 비교해보자.

## Circuit Switching
회선 교환(circuit switching)은 출발지와 목적지 사이 독립적이며 폐쇄적인 통신 연결로 구성되어 있다. 통신 과정에서 필요한 자원들을 요청 및 예약하는 on-demand 방식이기 때문에, 타 요인에 의해 방해받지 않는 안정적인 연결이다.

전화망이 가장 대표적인 회선 교환의 예시다. 송신자가 정보(음성, 팩스 등)를 보내기 전 네트워크에 의해 연결이 설정되고, 적절한 전송속도가 연결을 위해 reserve되어 일정한 수준의 전송률이 보장된다. 

## Packet Switching
데이터 전송 시, 송신을 위한 시스템은 데이터를 패킷(packet)이라는 작은 크기(L bit라 하자)의 블록으로 분할한다. 각 패킷은 특정 전송률(R)을 가지고 communication link와 packet switch(such as router)를 거치게 된다. 이 상황에선 패킷이 전송되기 위해 L/R의 시간이 소요될 것이다.

### Store and Forward
패킷 교환은 대개 store-and-forward라는 전송 방식을 이용한다. 간단히 말하면, 패킷 전체가 도착 후 패킷 스위치에 저장되어야 다음 링크로 이동하도록 하는 방식이다. 이럼으로써 중간에 전송 속도를 제어하거나, 변형 및 정정이 가능하게 된다.

위와 같은 상황을 가정해보자. 

Time | 1st packet | 2nd packet | 3rd packet
---|---|---|---
0 | source에서 출발 | 대기 | 대기
L/R | 라우터에 저장 후 목적지로 출발 | source에서 출발 | 대기
2L/R | 목적지 도착 | 라우터에 저장 후 목적지로 출발 | source에서 출발
3L/R | 목적지 도착 | 목적지 도착 | 라우터에 저장 후 목적지로 출발
4L/R | 목적지 도착 | 목적지 도착 | 목적지 도착

이렇게 총 4L/R의 시간이 소요될 것이다. 저장하지 않고 바로 보내면 store-and-forward에 의한 딜레이가 발생하지 않겠지만, 그래도 이러한 방식은 필요하다.

### Queueing
다수의 링크에 의한 큐잉(queuing)으로부터 비롯되는 문제도 있다. 여러 링크로부터 패킷이 스위치에게 오고, 이를 한번에 처리할 수 없다면 스위치는 대기할 패킷을 버퍼에 잠깐 저장해야 한다. 대기 패킷의 입장에선 바로 전송되지 못하므로 그로 인한 딜레이가 존재하고, 유한한 버퍼 크기로 인해 버퍼가 꽉 차있을 경우 패킷의 손실이 발생할 수도 있다. 

### Routing & Forwarding
라우터는 어떤 링크로부터 패킷을 받아, 다른 링크로 전달하는 역할을 한다. 이 때, 라우터는 목적지를 어떻게 결정할까? 각 라우터는 목적지에 해당하는 주소(혹은 일부)와 라우터의 출력 링크 사이의 매핑 정보를 저장하는 전달 테이블(forwarding table)을 가지고 있다. 이를 이용하여, 라우터는 도착한 패킷으로부터 주소를 읽고, 전달 테이블을 참조해 적절한 링크를 찾아 보낸다.

지금까지 패킷 교환에 대해 간단히 알아보았다. 여기서, 패킷 교환 네트워크에서 지연 및 손실이 발생할 수 있음을 알게 되었는데, 이 점에 대해 조금 더 자세히 알아보도록 하자.

### Packet Delay
네트워크를 일종의 그래프로 보고, 각 노드(라우터)에서 다른 인접한 노드로 데이터를 전달하는 경우를 생각해보자. 이 때 각 노드에서의 패킷 지연은 크게 네 가지 요소로 볼 수 있다.

> d_node = d_proc + d_queue + d_trans + d_prop

- d_node : 전체적인 노드 지연.
- d_proc : 처리 지연(processing delay). 패킷 헤더 조사 후 목적지를 결정하는 시간.
- d_queue : 큐잉 지연(queuing delay). 패킷이 큐잉되어 전송을 기다리는 시간.
- d_trans : 전송 지연(transmission delay). 전송률과 패킷 길이에 의한, 패킷을 링크로 전송하는 시간.
- d_prop : 전파 지연(propagation delay). 링크 전송 후, 목적지 노드까지 전파되는 시간.

전송 지연과 전파 지연이 혼동될 여지가 있는데, 전자는 라우터가 패킷을 내보내는 데 필요한 시간(`패킷 길이(L) / 전송률(R)`)이고, 후자는 physical link를 거쳐 이동하는 데 필요한 시간(`물리 링크 길이(d)/전파 속도(s)`)이다.

통신의 유형과 환경에 따라, 각 요소가 기여하는 비중이 다르다. 예를 들어, 단거리 통신의 경우 전파 지연은 무시할 수 있을 정도겠지만, 위성에 의한 연결의 경우 전파 지연은 그 비중이 상당히 커질 것이다.

큐잉 지연에 대해 잠깐 짚고 가보자. 큐잉 지연의 정도는 각각의 패킷의 관점에서도 다를 것이고 (가령 가장 먼저 온 패킷은 지연이 0이므로) 버퍼의 크기, 패킷의 길이, 트래픽 분포(periodical한지, burst한지) 등 많은 변수가 있다. 큐잉 지연을 표현하기 위한 방법도 통계적으로 다양한데, 우리는 러프하게 큐잉 지연에 영향을 주는 요소를 생각해볼 것이다.

큐가 빠지려면, 대기 중인 패킷이 전송되어야 한다. 즉, 패킷 길이와 전송률에 의존하는 셈인데, 그리고 패킷이 라우터에 도달함으로써 큐가 다시 쌓일 것이다. 평균 패킷 도달률을 a, 패킷 길이를 L, 대역폭을 R이라고 하면, 큐잉 지연은 `aL/R`에 의존함을 알 수 있다. 이 값이 0에 가까우면 적은 수준의 큐잉 지연이고, 1에 가까우면 큰 수준이며, 1을 넘으면 처리되는 양보다 쌓이는 패킷이 더 많아짐을 의미한다. 

### Packet Loss
`aL/R` 값이 1을 넘을 경우, 버퍼가 무한하다면 지연이 무한히 커지는 상황이 일어나겠지만, 실제론 버퍼는 유한한 용량을 가지므로, 그 용량을 초과한 패킷은 버려지게 된다.

### Throughput & Bottleneck
네트워크에서 경로 상 어떤 요소에서 지연이 발생하면, 전반적인 성능 저하를 초래하는 병목 현상(bottleneck)이 발생할 수 있다. 즉, 전송 경로가 처리율에 제약을 주는 제한 요소가 될 수 있다. 만약 라우터가 하나가 아닌 여러 개, 혹은 수십 개가 경로 상에 있다면 병목 현상은 더더욱 눈에 띌 수도 있다. 보통 네트워크의 코어는 굉장히 빠른 전송속도를 가지고 있어, 접속 네트워크가 병목 현상의 주된 요인이다.


지금까지 패킷 교환과 회선 교환을 알아보았는데, 둘은 그 방식이나 장단점이 뚜렷하게 구분되어 보인다. 간단하게 정리를 하면 다음과 같다.

　| Packet Switching | Circuit Switching
---|---|---
장점 | 높은 회선 이용률을 가진다. | 일정 수준의 통신 품질을 보장하며, 타 요인에 의해 방해받지 않는다.
단점 | 한정된 자원 하에서 통신 품질이 떨어질 수 있으며, 패킷 손실이 발생할 수 있다. | 네트워크 자원이 낭비될 수 있다.


# Protocol
프로토콜(protocol)은 말 그대로 규약이다. 사람 간의 의사소통에서 (명시적이지 않더라도) 일종의 규약을 지키는 것과 같다고 볼 수 있다. 인터넷에서의 프로토콜은 연결되는(통신하는) 개체 간 교환되는 데이터의 포맷, 순서, 송수신 방식뿐 아니라, 통신 상황에서의 각종 event들에 대한 행동을 정의한다. 통신은 수 없이 많은 종류가 있고, 그 하나하나에서도 많은 종류의 이벤트가 발생하므로, 프로토콜은 그만큼 인터넷 속에 만연해있고, 그만큼 중요하다.

## Protocol Stack
프로토콜은 계층(layer)화 되어있어, 각각의 프로토콜은 하나의 계층에 속한다. 네트워크는 수 많은 구성 요소로 이루어져 있는데, 이를 적절한 구조로 organize하여 구성 요소들을 보다 구조적이고 논리적으로 접근할 수 있게 된다. 또, 이러한 모듈화는 시스템의 유지 및 갱신의 유리하다는 장점도 있다. 계층화된 여러 계층의 프로토콜이 모여 프로토콜 스택(protocol stack)을 형성한다. 인터넷에선 다섯 개 계층의 프로토콜 스택을 사용하는데, 다음과 같다.

![](/imgs/network/net1.png)

- Application : 네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 상주한다.
- Transport : 클라이언트와 서버 간 애플리케이션 계층 메세지를 전송하는 서비스를 제공한다.
- Network : 한 호스트에서 다른 호스트로 데이터그램(datagram)을 라우팅한다.
- Link : 출발지-목적지 사이의 패킷 스위치를 통해 데이터그램을 라우팅한다. 
- Physical : 프레임 내부의 각 비트를 한 노드에서 다른 노드로 이동시킨다.

각각의 계층을 상위 계층에서 하위 계층으로 하나씩 살펴보는 하향식 접근을 할 예정이다. (그래서 책 제목도 A Top-Down Approach다) 

## Encapsulation
캡슐화(encapsulation)는 네트워킹에서 모듈화된 통신을 위한 방법이다. OOP에서도 캡슐화라는 개념이 있었는데, 여기서 캡슐화를 쉽게 말하면, 데이터를 랩핑하는 것이라 볼 수 있다. 캡슐화된 메세지를 전송하는 것은 편지를 보내는 과정과 상당히 유사하다. 편지를 보내기 위해, 편지 봉투와 우편을 사 발/수신인을 기입하고(encapsulation), 수신인은 이를 확인하고 받은 뒤, 봉투를 제거해 내용물을 읽는다(decapsulation). 그렇다면 이게 왜 필요한가? 하면, 특정 계층은 그 계층에 해당하는 기능만 수행함으로써 모듈성이 향상되고, 그러면서 다른 모듈에게 미치는 영향을 최소화할 수 있기 때문이다.

캡슐화는 상위 계층부터 시작해서 내려가고, 역캡슐화는 그와 반대로 이루어진다. 편지 포장을 생각하면 그 이유가 납득이 될 것이다. 


# 마치며
내용을 좀 번잡하게 써놨는데, 사진도 날라가서 더 이해하기 힘들어졌다. 나중에 다시 정리해야지