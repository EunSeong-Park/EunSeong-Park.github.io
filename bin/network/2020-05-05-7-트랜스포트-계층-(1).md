---
title:  "[Networking 7] 트랜스포트 계층 (1)"
toc: true
tags: Networking
---

# Intro
드디어 애플리케이션 계층이 끝났다! 이젠 다음(아래) 계층인 트랜스포트 계층(transport layer)에 대해 다룬다. 트랜스포트 계층의 서비스가 동작하는 원리와 방식을 알아보고, 트랜스포트 계층의 프로토콜들을 하나하나 짚어볼 예정이다. 열심히 달려보자.


# Transport Layer
트랜스포트 계층의 프로토콜은 서로 다른 호스트에서 동작하는 (애플리케이션) 프로세스 간의 논리적 통신(logical communication)을 제공한다. 이들은 종단 시스템(end system)에서 동작하여, 송신자 쪽에선 메세지를 세그먼트(segment)로 쪼개어 네트워크 계층으로 보내고, 수신자 쪽에선 쪼개진 세그먼트를 재결합하여 애플리케이션 계층으로 보낸다.

네트워크 계층과 트랜스포트 계층의 역할을 명확히 짚고 넘어갈 필요가 있다. 네트워크 계층은 호스트 간의 통신을, 트랜스포트 계층은 프로세스 간의 통신을 제공한다는 점에 그 차이가 있다. 책에 괜찮은 비유가 있다.

> 두 집안(hosts)에는 각각 몇 명의 아이(processes)가 있는데, 각 집에서 한 아이(transport protocol)는 받은 우편(app msgs)들을 집에서 수신자에게 나눠주는 역할을 한다. 여기서 우편 서비스(network layer protocol)는 발신자의 집에서 수신자의 집으로만 우편을 배달하지, 직접 수신인에게 우편을 가져다주지는 않는다.

## Multiplexing & Demultiplexing
모두가 알겠지만, 인터넷(혹은 TCP/IP 네트워크)에선 TCP와 UDP, 두 개의 주요 트랜스포트 프로토콜이 존재하고, 애플리케이션은 이들 하나 이상 사용할 수 있다. TCP는 연결 지향형의 신뢰적 서비스를 제공하고, UDP는 비신뢰적이고 비연결형의 서비스를 제공한다. 둘 다 공통적으로 대역폭과 지연에 대한 보장(guarantee)을 하지 못한다는 점을 주의하자. TCP와 UDP는 하도 많이 얘기를 해서 자세한 사항은 생략한다. 

아무튼 TCP와 UDP 모두 트랜스포트 계층에서 종단 시스템 사이 프로세스 간의 전달을 담당한다. 이는 다중화(multiplexing)와 역다중화(demultiplexing)으로 구현된다. 멀티플렉싱과 디멀티플렉싱은 여러 과목에서 접해봤기 때문에 그 개념과 의미는 이미 잘 파악하고 있을 것이다. 그럼 무엇에 대해 Mux/DeMux를 수행할까? 바로 각 프로세스, 또는 소켓에 대해서다. 송신자는 데이터를 여러 소켓으로부터 받아 트랜스포트 헤더를 첨가하고(각 계층이 헤더를 붙인다는 내용은 앞서 언급했을 것이다), 수신자는 여러 송신자로부터 받은 데이터로부터 헤더를 읽어 적절한 소켓으로 분배한다. 이 때, 트랜스포트 계층은 데이터를 직접 프로세스로 전달하지 않고, 소켓을 통해 전달한다는 점을 유의해야 한다.

![](imgs/network/net21.png)

그럼 디멀티플렉싱 과정에선 어떻게 메세지로부터 헤더를 읽고, 이를 어떻게 적절한 소켓으로 분배할까? 답은 트랜스포트 계층 세그먼트를 보면 알 수 있다. TCP나 UDP나, 공통적으로 세그먼트가 출발지(source) 포트와 목적지(dest) 포트의 번호를 포함하고 있다. 앞서 배웠지만, 포트는 0부터 0xFFFF까지 16비트 정수로 나타내어지고, 이중 0-1023은 well-known port이기 때문에, 사용이 제한된다. 네트워크 애플리케이션 개발 시 애플리케이션에 포트 번호를 반드시 할당해야 하며, 호스트의 각 소켓은 포트 번호를 할당받기 때문에, (IP 주소와) 포트 번호를 검사하는 것으로 그 번호에 대응하는 적절할 소켓에 메세지를 보낼 수 있다. 

![](imgs/network/net22.png)

이는 UDP에서의 기본적인 기능이고, TCP도 이를 포함하지만, TCP는 더 많은 기능을 제공하며 더 많은 의미를 가지고 있다. 이는 조금 이따가 알아보자.

### Connectionless Demultimplexing
비연결형, 즉 UDP에서의 디멀티플렉싱을 조금 더 알아보자. 그 전에, 데이터그램(datagram)은 목적지의 IP와 포트 번호를 명시해주어야 하고, 이 둘에 의해 목적지를 특정한다는 점을 기억하자. 호스트가 UDP 세그먼트를 받을 때, 목적지 포트를 확인하고 이를 해당 포트에 대응되는 소켓에게 보내는데, 출발지가 어떻게 생겨먹었든 목적지 IP와 포트만 같다면 반드시 같은 소켓과 프로세스를 향하게 된다.

그런데, (두 칸 위 사진에서) 왜 세그먼트는 출발지 포트를 포함하고 있을까? 이는 복귀 주소의 한 부분으로 사용되어, 수신자가 송신자에게 세그먼트를 다시 보내려 하면 수신자는 송신자의 목적지 포트 번호를 해당 세그먼트에서 찾는다. 이후 추출한 포트 번호와 IP를 이용해 새로운 세그먼트를 원래의 송신자에게 보낼 수 있다. 와우!

### Connection-Oriented Demultiplexing
그럼 TCP에선 어떨까? TCP의 경우엔 조금 더 복잡하다.

우선 TCP 소켓은 그것을 식별하기 위해 UDP의 경우에 더해 출발지의 IP와 포트 번호, 총 네 가지 요소가 필요하다. 그래서 다른 출발지 IP 또는 포트에서 온 TCP 세그먼트는 서로 다른 소켓으로 가게 된다. 이러한 점을 생각해보면, 클라이언트와 TCP 통신을 하는 웹 서버라면 클라이언트 각각을 위한 소켓이 내부에 할당되어 있을 것이다. 비지속형(non-persistent) HTTP라면? 요청 하나하나에 따른 소켓이 할당될 것이다. 오우야... 뭐 소켓 수만큼 프로세스가 할당해서 쓸 수도 있지만, threaded program을 설계해 스레드에게 할당하는 게 좋지 않을까?

## UDP
앞서, 우리는 트랜스포트 계층에서 해야하는 최소한의 동작이 뭔지 알고 있다. 바로 멀티플렉싱과 디멀티플렉싱이다. 사실 트랜스포트 계층을 설계할 때 그것만 잘 구현해도 어느 정도는 동작한다. UDP는 여기에 아주 간단한 오류 검사 기능만을 IP에 추가한 형태다. 그래서 UDP는 데이터 손실과 다수의 데이터가 전송되었을 때의 전달 순서를 보장하지 않는다. 이렇게 보면 UDP는 TCP에 비해 꽤 열등해 보이는 느낌을 받지만, 실제론 그렇지 않다. (그렇다고 더 낫다는 뜻도 아니고, 일장일단이 있다 이 소리다) 왜냐?

- 애플리케이션에서 데이터 송신에 대한 정교한 제어를 할 수 있다. TCP가 신뢰적인 통신을 위해 (혼잡 제어에서) 과도한 재전송 및 조절을 수행하면, 애플리케이션이 필요로하는 최소한의 쓰루풋을 보장하지 못할 수 있다. 이런 점에서 loss-tolerant하고 최소 전송률을 요구하는 애플리케이션은 UDP를 채택하고, 필요한 기능을 애플리케이션 레벨에서 추가적으로 구현해 사용할 수 있다.
- 비연결형이기 때문에, 핸드셰이킹(handshaking)을 위한 지연이 발생하지 않는다.
- 연결 상태를 유지하지 않으므로, 그에 대한 데이터 또한 저장하지 않는다. 그래서 공간 절약과 함께 조금 더 많은 클라이언트를 수용할 수 있다.
- 패킷 헤더가 더 간단하게 설계되어 있어, 그에 따른 패킷 오버헤드(overhead)가 적다.

아무튼, UDP 세그먼트는 다음과 같은 구조를 가진다.

![](imgs/network/net23.png)

여기서 `length`는 헤더를 포함한 UDP 세그먼트의 길이를, `checksum`은 오류 검출을 위한 비트 덩어리다. UDP는 세그먼트 내의 모든 내용들을 16비트 정수들로 여겨, 이들을 각각 반복적으로 더해(wrap-around 방식의 받아올림을 수행하여, 오버플로우가 발생하는 carryout은 LSB에 보낸다), 최종 결과의 1's complement를 체크섬으로 여긴다. 송신자는 이를 보내고, 수신자는 받은 세그먼트에 대해 1's complement를 제외하고 같은 동작을 수행하여, 그 결과를 `checksum`과 더해본다. 그럼 보수 성질에 의해, 정상적으로 전달된 경우 111...111과 같은 합이 나오게 된다. 그렇지 않다면 오류가 발생한 것으로 본다. 물론 이 방법은 완벽하지 않은데, 여러 개의 비트가 삑날 때 어쩌다가 결과가 잘 맞아떨어질 수 있기 때문이다. 첫 파트가 1100110011001100이고, 두 번째 파트가 0011001100110011이라고 해보자. 여기서 아주 개박살이 나서 1111...1111과 0000...0000으로 변형되었다고 치자. 대놓고 문제가 발생했지만 이를 체크섬으로 검출할 수 있을까? 그저 간단한 오류 검사일 뿐이다. 물론 저런 참사가 일어날 확률은 생각보다 낮고, 그만큼 꽤 잘 잡을 수 있다.

## TCP
TCP의 가장 큰 특징 중 하나는, reliable하다는 점이다. 신뢰적이라는 말을 다시 명확히 할 필요가 있는데, 신뢰적인 채널에서는 모든 전송된 데이터가 손상(비트 반전)되지 않고, 전송된 순서를 맞춰 전달된다. 이는 상당히 어려운 문제다. 왜냐? 트랜스포트 계층에서 열심히 신뢰성 있게 데이터를 전송했는데, 네트워크 계층 또는 그 아래 계층에서 똥을 싸 손실 또는 손상이 발생했다면, 이는 신뢰적이라고 할 수 없기 때문이다. 그래서 하위 채널에서의 손실이 발생했을 때의 매커니즘도 고려한 프로토콜이 필요하다. 

우선, 패킷이 손실되더라도, 하부 채널은 패킷들의 순서를 바꾸지 않아, 전달 순서는 보장된다는 가정을 하고 시작하자. 신뢰적 데이터 전송을 위해 아래와 같은 인터페이스를 생각할 수 있다. rdt는 신뢰적인 데이터 전송을, udt는 비신뢰적인 데이터 전송을 의미한다.

![](imgs/network/net24.png)

구현할 프로토콜의 복잡도는 비신뢰적인 하위 계층의 특성에 달려있다. 완전히 신뢰적인 채널이라면 훨씬 간단할테고, 개판 5분 전이라면 그렇지 않을 것이다. 그래서 이런 신뢰적인 데이터 전송을 어떻게 하느냐? 다음 포스트에서 할 것이다.








