---
title:  "[Networking 10] 트랜스포트 계층 (4)"
toc: true
tags: Networking
---

# Intro
이번엔 TCP에서 혼잡 제어(Congestion control)를 비롯한 나머지 토픽들을 짚고 TCP를 끝낼 것이다. 야호!


# Congestion Control
## Congestion
혼잡(congestion)이란, 네트워크가 처리하기에 너무 많은 데이터가 전송됨을 의미한다. 라우터(router)는 혼잡으로 인해 큐잉으로 인한 지연이나 버퍼 오버플로우를 겪을 수 있다. 조금 더 자세히 알아보자.

### Causes/Costs of Congestion (1)
두 송신자와 두 수신자, 그리고 무한 버퍼의 라우터를 생각해보자. 재전송은 없다고 가정하고, 라우터에선 R의 용량을 가지는 공유 출력 링크를 통해 데이터가 나간다.

![](/imgs/network/net41.png)

딱 봐도 출력 링크의 용량이 제한 요인이 되어 느려지거나 막힐 게 보인다. 실제로도 그런데, 각각의 연결은 최대 $\frac{R}{2}$의 쓰루풋을 가질 테고, 버퍼는 계속 쌓으면서 전송률($\lambda$)이 $\frac{R}{2}$에 가까워질수록 지연은 급격히 늘어난다.

![](/imgs/network/net42.png)

### Causes/Costs of Congestion (2)
위의 상황에서, 라우터의 버퍼가 유한함을 가정해보자. 또, 보다 TCP스럽게, 타임아웃 패킷은 재전송됨을 가정하자. 만약 버퍼가 터져서 패킷이 라우터에서 버려진다면, 이는 송신자에 의해 재전송될 것이다.

만약 송신자 측에서 라우터의 버퍼가 남아있는지의 여부를 알고, 그 때만 패킷을 보낼 수 있다면 행복한 네트워크가 될 것이다. 그럼 라우터에서의 패킷 손실도 발생하지 않고 재전송을 위한 별도의 비용도 발생하지 않으니 말이다.

하지만 현실은 녹록지 않아, 버려져서 타임아웃이 된 걸 확인해야 재전송을 한다. 심지어, 큐에서 지연이 되어 타임아웃이 되어버린, 즉 손실되지 않은 패킷조차 재전송될 수 있다. 이는 분명한 자원 낭비다.

![](/imgs/network/net43.png)

### Causes/Costs of Congestion (3)

![](/imgs/network/net44.png)

이번엔 조금 더 복잡하다. 4개의 송신자와 유한 버퍼, 그리고 멀티홉(multihop) 경로를 포함하는 네트워크다. 물론 타임아웃과 재전송의 가능성이 있다.

이러한 구조에서의 문제점은, 큰 트래픽이 특정 라우터 및 링크에서 경쟁을 할 수 있다는 점이다. 특정 송신자로부터 굉장히 큰 데이터가 출발해, 이것이 어떤 경로를 막는다면 다른 연결의 쓰루풋은 심하게 저하될 수 있다.

![](/imgs/network/net45.png)

과도한 혼잡으로 인하여 쓰루풋은 하락하다 못해 0이 되는, 교착 상태와 같은 현상이 발생할 수 있다. 이러한 상황을 congestion collapse라 한다. 물론 이런 상황은 일어나지 않도록 해야 하고, 그 방법이 바로 혼잡 제어다.

## TCP Congestion Control
IP 계층에서는 혼잡에 관해 종단 시스템(end system)에게 어떠한 직접적인 피드백도 제공하지 않는다. 즉, 관찰된 네트워크의 행동을 기반으로 종단 시스템 측에서 추측해야 한다. 

이제부터 TCP에서 사용되는, 혼잡 제어를 가능한 한 고효율/고성능으로 수행하도록 하는 방법을 하나하나 알아볼 것이다.

### Congestion Window
우리는 `cwnd`(congestion window)라는 추가적인 변수를 도입해, 송신자가 보낼 수 있는 데이터의 양을 제한하도록 한다. `LastByteSend - LastByteACKed <= min(cwnd, rwnd)`이며(흐름 제어도 고려하여), 이로 인해 송신율은 대략 $\frac{cwnd}{RTT}$가 된다.

![](/imgs/network/net46.png)

### TCP Slow Start
송신자는 연결 초반에 가능한 대역폭 수준을 빠르게 찾기 위해 슬로 스타트(slow start) 기법을 사용한다.

연결 시작 시, 전송자는 `cwnd`를 1로 초기화한 뒤, exponential하게 올려가면서 전송한다. 이는 첫 손실 이벤트가 발생했을 때 중단된다. 첫 손실 발생 시, `cwnd`를 다시 1로 초기화 하고, slow start의 임계치, `ssthresh`를 `cwnd/2`로 설정하여, 다시 윈도우를 늘려간다. 임계치를 넘기면 슬로 스타트는 종료되고, 혼잡 회피 모드(congestion avoidance)로 넘어간다.

### Congestion Avoidance
슬로 스타트 두 번째 시도로부터 윈도우가 임계치를 넘고 나면, 이는 혼잡 회피 모드로 전환된다. 성공적으로 ACK를 수신할 때마다 `cwnd`는 그것의 역수만큼 증가한다. (뭐?) 그러면 윈도우 사이즈는 대충 선형적으로 증가하는 것처럼 보인다.

이후 또 손실이 발생했다면, 손실 시점의 절반을 임계치로 잡고 같은 과정을 다시 반복할 수도 있지만(TCP-Tahoe가 그렇다), TCP-Reno라는 TCP 버전같은 경우엔 빠른 회복(fast recovery) 모드로 넘어간다.

### Fast Recovery
빠른 회복에서는 이후 재시작 시 `cwnd`를 1로 초기화하기 보단 조금 더 높은 지점에서 시작한다. 즉,

`ssthresh = min(cwnd, receiver's advertised window)/2`

![](/imgs/network/net47.png)

괜찮은 예시가 있다.

![](/imgs/network/net48.png)

### FSM
위 세 가지 혼잡 제어 방법을 FSM으로 정리하면 다음과 같다. 앞 내용을 이해했다면, FSM을 보는 게 그 흐름을 이해하는 데 더 도움이 될 것이다.

![](/imgs/network/net49.png)

### Congestion Detection
이제 네트워크 경로 상의 혼잡을 어떻게 감지하는지 알아보자. 타임아웃에 의해, 혹은 fast retransmission에 의해, 3개의 중복 ACK를 받으면 송신자는 손실이 발생했음을 알 수 있다. 라우터의 버퍼 오버플로우도 결과적으로 손실 및 중복 ACK를 발생시키고, 송신자는 이를 통해 혼잡을 확인한다.

반대로, 혼잡이 해결되었다면 송신자는 정상적인 ACK를 받아 네트워크가 잘 돌아가고 있음을 확인할 수 있다. 그리고 이는 혼잡 윈도우, `cwnd`를 다시 증가시키는 데 사용된다.

달리 말하면, 송신자는 ACK의 수신 상태를 기초로 데이터 패킷 전송을 제어한다. 이러한 방식을 ACK clocking이라고 한다.

### Throughput
결국 이러한 혼잡 제어 방식은 톱니바퀴 모양의 윈도우 사이즈를 그리게 된다. 이러한 방식을 AIMD(Additive-Increase, Multiplicative Decrease)라고 부른다. 왜냐? 증가할 땐 선형적이지만, 감소할 땐 반토막을 내버리니 말이다.

간단하게 생각해보면, 평균 윈도우 사이즈는 최대의 4분의 3정도를 띠고, 이것은 TCP의 쓰루풋 성능($\frac{3}{4} \frac{W}{RTT}$)이기도 하다.

![](/imgs/network/net50.png)

## Fairness
다수의($k$라고 하자) TCP 세션이 존재하고, 이것이 동일한 bottleneck link with bandwidth R을 가진다고 하자. 이 때, fairness가 지켜지는 통신이라면 각각 동일한 수준으로($\frac{R}{k}$) 링크를 이용해야 한다.

![](/imgs/network/net51.png)

TCP는 fairness가 꽤 잘 지켜지는데, 그것은 위의 혼잡 제어 알고리즘 때문이다. 어느 시점에서 시작하든 이들은 동일한 대역폭 지점으로 수렴하게 되어 있다. 그것도 (multiplicative decrease에 의해) 빠르게..!

![](/imgs/network/net52.png)

### UDP
이러한 전송률의 조정은 일부 매체에서는 썩 반가운 일이 아니다. 특히 대용량 멀티미디어의 경우 더더욱 그렇다. 그런 맥락에서 UDP는 공평하지 않고, 패킷도 조금 날려먹고, 전송률도 조정되지 않는다. 하지만 이러한 점은 loss-tolerance이면서 어느 정도의 전송률의 보장이 필요한 상황에서는 유리하게 작용한다.


# 마치며
이제 트랜스포트 계층도 끝났다. FSM은 눈이 아파서 꼼꼼히 확인해보지 않은 게 좀 아쉽다. 나중에 퀴즈를 치거나 하면 다시 보겠지... 아무튼 이제 네트워크 계층을 배울 시간이다. 학기가 한 달 남았는데 다 할 수 있을까..?