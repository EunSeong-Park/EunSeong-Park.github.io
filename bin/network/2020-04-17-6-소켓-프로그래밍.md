---
title:  "[Networking 6] 소켓 프로그래밍"
toc: true
tags: Networking
---

# Intro
소켓과 이를 이용한 소켓 프로그래밍의 개념은 네트워크 애플리케이션을 작성하기 위한 구체적인 방법을 제공한다. 그래서 애플리케이션 계층 파트의 가장 마지막에 위치해 있는데, 열심히 알아보도록 하자.


# Socket Overview
API(Application Programming Interface)는 특정 서비스에 대한 추상화(abstraction)가 적용된 프로그래밍 인터페이스로, 추상화의 적용으로 우리는 implemetation에 관한 detail을 (어느 정도) 생략하고, 그것의 기능에 집중할 수 있다. API는 그것의 목적에 맞는 함수, 자료 구조, 상수 등을 포함할 수 있다.

소켓(socket)이란, 네트워크 애플리케이션이 네트워크에서 데이터를 송수신하고 통신할 수 있도록 애플리케이션과 네트워크를 잇는 일종의 통로다. 가전 제품의 플러그를 꽂기 위한 소켓을 생각해도 어느 정도 의미가 통한다. 아무튼 소켓 API는 그러한 소켓을 구현하고 이용하기 위한, 네트워크 프로그래밍 인터페이스라고 볼 수 있다.

소켓은 크게 TCP를 이용하는 소켓(stream socket)과, UDP를 이용하는 소켓(datagram socket)으로 나누어 볼 수 있다. 

TCP | UDP
---|---
연결 지향형(connection-oriented), 연결에서 초기 설정과 종료를 필요로 한다. | 비연결형(connection-less)
신뢰적(reliable) 바이트 스트림 채널. (헤더에 길이를 명시하고) 메세지를 단일 바이트의 스트림으로 본다. | 독립적 패킷에 의한 데이터 전송. 기본적으로, 메세지 단위로 구분된다.
지연의 정도와 편차가 큼 | 지연의 정도와 편차가 상대적으로 작음


# Socket API
## TCP
TCP 클라이언트-서버 통신에서는 데이터의 송수신을 위해선 먼저 TCP 연결을 설정해야 한다.

![](/imgs/network/net17.png)

### Connection establishment
기본적으로 연결은 클라이언트의 요청으로 시작되는데, 이를 위해선 서버는 요청을 받을 준비가 되어있어야 한다. 즉, 서버는 자신의 프로세스가 실행되고 있어야 하며, 초기 접속을 받아들이기 위한 몇 가지 작업을 해야 한다. `socket`, `bind`, `listen`이 여기에 해당된다.

- `socket`: 통신할 도메인 영역, 프로토콜 종류(TCP는 `SOCK_STREAM`) 등을 지정함으로써 자신의 소켓과 그것의 식별자(descriptor)를 생성한다.
- `bind`: 소켓을 서버 소켓으로 등록하여 연결에 사용하기 위해, IP 주소와 포트 번호를 지정한다.
- `listen`: 클라이언트 대기를 위해 대기 큐를 생성한다.

이후 `accept`를 호출하여 클라이언트의 연결 요청을 대기한다. 연결 요청이 소켓에 도달하면, 그 연결을 식별하기 위한 디스크립터를 리턴하고, 본격적으로 데이터 송수신의 준비가 완료된다.

클라이언트 또한 `socket`을 통해 자신의 소켓을 생성한 다음, `connect`를 통해 지정된 소켓에 연결을 시도한다. `connect`는 연결이 수립되거나 실패할 때까지 대기한다.

### Data Tansfer
클라이언트와 서버는 서로에게 읽기 및 쓰기를 할 수 있다.

- `send`: 지정된 소켓으로 데이터를 보낸다. 전송 후 송신 데이터의 크기(in byte)를 리턴한다. 소켓이 블로킹(blocking) 모드라면, 모든 데이터가 보내질 때까지 `send`는 블록된다. 만약 non-blocking 모드로 공간 부족 등의 문제가 발생한다면 전송이 완전히 이루어지지 않아 리턴값과 실제 데이터 크기는 다를 수 있다.(이 경우 재시도 해야한다!) `send`는 `write`나 `writev`로 사용할 수도 있다.
- `recv`: 소켓으로부터 특정 바이트를 읽고, 읽은 데이터의 크기(in byte)를 리턴한다. 읽을 수 있는 데이터가 없다면 블록(block)되고, 일부만 읽을 수 있다면 리턴값과 실제 데이터 크기가 다를 수 있다.(이 경우에도 재시도 해야한다!) 또, 소켓이 닫히면 리턴값은 0이 되는데, 에러는 아님에 주의하자. `recv`는 `read` 또는 `readv`로 사용할 수도 있다.

### Termination
클라이언트와 서버 모두 `close`로 해당 소켓을 닫아 연결을 종료할 수 있다.

## UDP
UDP 클라이언트-서버 통신도 TCP의 경우와 꽤 유사하지만, 몇 가지는 다르다. 우선 소켓 생성 과정에서 프로토콜을 `SOCK_DGRAM`(TCP는 `SOCK_STREAM`이다) 으로 지정하는 점과, 연결 지향형이 아니기 때문에 연결을 요청하고 수립하는 과정이 없다. 즉, `connect`와 `accept`를 필요로 하지 않는다.

![](/imgs/network/net18.png)

중요한 포인트는 데이터 전송 과정에 있다. UDP는 패킷을 통한 데이터 전송이 이루어지기 때문에, TCP와는 다른 전송 방식이 필요하다. 그래서 `send`와 `recv` 대신, `sendto`와 `recvfrom`이 있다.

- `sendto`: 패킷을 지정된 주소-포트로 전송한다. 이 또한 `send`와 마찬가지로 전송 데이터 크기를 리턴한다. TCP와 달리 패킷화(packetized)되어 있으므로, 데이터는 전부 보내지거나 전부 보내지지 않는다. 즉, 리턴값은 데이터 길이 그 자체거나 0이 될 것이다.
- `recvfrom`: 소켓에 해당하는 데이터를 특정 바이트만큼 읽고, 그 크기를 리턴한다. 위와 마찬가지의 이유로, TCP와 달리 zero return이 연결이 종료됨을 의미하지 않는다. 애초에 그런 개념이 UDP에 없기도 하다.


# I/O Multiplexing
서버 연결에서 중요한 이슈가 하나 있는데, 다수로부터의 입력을 어떻게 처리하느냐다. 다수의 소켓으로부터, 주로 표준 입력(stdin)으로 데이터가 들어오는데, 문제는 데이터가 언제 올 지도 알 수 없고, `recv`는 데이터 읽기가 불가능할 경우 블록을 걸어 다른 곳으로부터의 데이터도 읽을 수 없는 상황이 온다.

가능한 해결책이 여럿 있는데, 아마 멀티스레드 방식이 가장 먼저 떠오르겠지만, 이는 그 자체로 너무 복잡하다(내가 모르기도 하고). Non-blocking 소켓을 이용해 블록을 막는 방법도 있다. `fcntl` 함수로 소켓을 논블로킹으로 설정할 수 있는데, 무한루프를 돌리며 계속 읽기를 시도하는 방식이기 때문에 CPU 자원을 낭비하게 된다. 아래 코드만 봐도 무엇이 문제인지 쉽게 알 수 있을 것이다.

![](imgs/network/net19.png)

그래서, 우리는 `select` 함수로 I/O 멀티플렉싱을 적용해 간단하게 이 문제를 해결할 수 있다. `select`는 지정한 범위의 소켓을 순회하며, `select`가 적용될 소켓들에 한해(`FD_SET`에 의해 설정된다) 파일에 변화가 생긴 경우 1을 리턴받는다. `while (1)` 처럼 무한루프를 돌리며 체크하는 것보다 덜 무식한 방법이라 할 수 있겠다. 아래 코드를 보면 어떻게 작동하는지 알 수 있을 것이다.
 
![](imgs/network/net20.png)





