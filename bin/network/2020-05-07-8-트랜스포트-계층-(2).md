---
title:  "[Networking 8] 트랜스포트 계층 (2)"
toc: true
tags: Networking
---

# Intro
신뢰적인 데이터 전송은 어떻게 구현되고 이루어지는 걸까? 이번 포스트에선 이를 중점적으로 알아보고, 너무 길면 끊고 너무 짧으면 다음 파트도 하고...


# Reliable Data Transfer
수신자, 송신자 측면에서의 `rdt`(reliable data transfer)를 알아보고, 이를 점차 복잡하고 강력한 프로토콜로 발전시켜 나가보자. 우선은 가장 간단한 경우부터 생각해보자. 우리는 단방향의(unidirectional) 데이터 전송만을 고려할 것이다.

## `rdt1.0`
`rdt1.0`은 하위 채널이 완전히 신뢰적인, 아주 간단한 경우의 프로토콜이다. 즉, 조금의 비트 반전도, 패킷의 손실도 없는 채널 위에서 통신하는 경우다. 여기서는 송신자/수신자 각각에 대해, 분리된 FSM(Finite-State Machine)이 존재하여 다음과 같은 동작을 수행한다.

![](/imgs/network/net25.png)

FSM에서 arrow는 state의 변화를, 수평선 위는 그러한 변화를 일으키는 event를, 아래는 event에 대한 action을 나타낸다. 송신자/수신자엔 하나의 FSM만 존재하므로, 모든 state의 변화는 자신에게 돌아온다. 또, initial state는 dotted arrow에 의해 일어남을 알아두자.

송신자 측면에서 먼저 살펴보도록 하자. `rdt_send`에 의해 송신자는 상위 계층으로부터 데이터를 수신한다. 그 후, 데이터를 기반으로 패킷을 생성하고, `udt_send(packet)`을 통해 채널로 패킷을 송신한다. `rdt_send(data)`가 이벤트로 여겨지는 건, 그것(또는 그에 해당하는 프로시저 호출)이 상위 계층에 있는 애플리케이션에 의해 발생하기 때문이다.

수신자 측에선 어떨까? 하위 채널로부터 패킷을 수신하는, `rdt_rcv` 이벤트가 발생하면, 패킷으로부터 데이터를 추출하여(`extract`), 데이터를 상위 계층으로 전송한다. 송신자의 경우와 비슷한 맥락에서, `rdt_rcv` 이벤트는 하위 계층으로부터의 프로시저 콜에 의해 발생한다.

이처럼 완전히 신뢰적인 채널에서는 오류가 발생하지 않기 때문에 그 과정이 매우 간단하고, 수신 측에서 송신 측에게 어떠한 피드백을 줄 필요도 없다. 

## `rdt2.0`
`rdt2.0`은 패킷 내의 비트 오류가 하위 채널에서 발생할 수 있는 경우를 다룬다. 다만, 이러한 경우에도 여전히 전달 순서는 계속 보장함을 가정한다. 

그러면 `rdt2.0`은 어떻게 비트 오류 여부를 파악하고, 어떻게 이를 처리할까? ARQ(Automatic Repeat reQuest) 프로토콜은 '재전송'을 기반으로 비트 오류를 해결하는 신뢰적 데이터 전송 프로토콜이다. ARQ 프로토콜은 수신자에게 ACK(Acknowledgement, 수신자가 패킷을 성공적으로 수신함) 또는 NAK(NegativeAcknowledgement, 수신자가 받은 패킷에 오류가 있음)을 보냄으로써 송신자가 재전송이 필요한지를 알 수 있도록 한다. 간단히 정리하여 ARQ 프로토콜은 다음과 같은 기능을 가진다.

1. 오류 검출 : 이전에 알아보았듯, UDP는 체크섬을 이용해 오류를 검출한다. 다양한 오류 검출 방법이 있는데, 이는 링크 계층(chapter 5-2)파트에 자세히 나와있다.
2. 피드백 : 수신자가 송신자에게 ACK/NAK 패킷(1비트로도 충분하다)을 보내 송신자에게 피드백을 준다.
3. 재전송 : 피드백을 받은 송신자가 오류가 있는 패킷을 재전송할 수 있도록 한다.

이러한 프로토콜을 FSM으로 나타내어 볼 수 있다. 하나하나 확인해보자.

![](/imgs/network/net26.png)

이번엔 수신자 측에서 먼저 보자. 수신자 측에는 하나의 FSM이 존재한다. `rdt_rcv && corrupt`는 패킷을 받았으나 오류가 검출되는 이벤트다. 이 경우 NAK를 송신자에게 보내면 된다. 그렇지 않다면(`noncorrupt`)? 데이터 추출 및 상위 계층으로의 전달을 수행하고, 송신자 측에게 ACK를 전송한다.

송신자는 두 state를 가진다. 상위 계층으로부터의 (메세지를 보내기 위한) 프로시저 호출을 기다리거나, 수신자 측으로부터 ACK 또는 NAK를 기다리거나. 전자의 상태에서, 상위 계층으로부터 데이터가 오면 이를 패킷화하여 수신자에게 보내고 상태를 전이시킨다. 이후 NAK를 받으면 상태를 전이하지 않고 다시 패킷을 보내며, ACK를 받으면 다시 프로시저 호출을 기다리면 된다.

이는 꽤 잘 작동하는 것처럼 보이지만, 꽤 심각한 문제가 하나 있다. 바로 ACK나 NAK가 손상되는 경우를 고려하지 않았다는 점이다. 이를 어떻게 해결해야 할까? 오류 검출은 ACK나 NAK에도 체크섬 또는 다른 오류 검출 메서드를 적용하는 걸로 해결할 수 있을 것 같다. 그렇다면 복구는? 다음과 같은 방법을 생각해 볼 수 있다. 물론 내가 생각한 건 아니고 책이 그렇다더라.

- 송신자가 수신자에게 ACK 또는 NAK의 재전송을 요청할 수 있다. 다만 이는, ACK/NAK 재전송에 대한 또 다른 타입의 메세지를 필요로 한다. 만약 그마저도 손상이 일어난다면?
- (오류가 발생한)ACK나 NAK를 수신할 때 그에 해당하는 패킷을 재전송한다. 하지만 이러면 수신자는 패킷이 새로운 데이터를 포함한 건지, 재전송된 패킷인지 구분할 수가 없다. 

이를 해결하기 위해, 패킷 내에 sequence number를 나타내는 필드를 추가하여 송신자가 넘버링을 하는 방법을 생각해보자. 어차피 순서가 보장됨을 가정하기 때문에, 진짜로 도착 순서를 넘버링하는 등의 삽질은 필요 없고, 재전송 패킷 여부 정도만 구분해주는 걸로도 충분할 것이다. 이러한 기법이 적용된 모델이 바로 `rdt2.1`이다. 수신자의 FSM은 다음과 같다.

![](/imgs/network/net27.png)

송신자는 다음과 같다. 송신자는 원래 기능에 더해, 패킷이 복제되었는지의 여부를 시퀀스 넘버를 통해 확인해야 한다.

![](/imgs/network/net28.png)

각각 상태가 두 배로 늘어났다. 점점 복잡해진다... 아무튼 송신자는 시퀀스 넘버를 추가하는 작업과 ACK/NAK가 손상되었는지를 판단하는 작업을 수행해야 한다.

`rdt2.2`는 `rdt2.1`과 같은 기능을 수행하지만 NAK-free한, 즉, ACK만을 사용하는 프로토콜이다. NAK를 보내는 대신, 가장 마지막에 성공적으로 수신한 패킷에 대한 ACK를 보내는데, 이럼으로써 송신자는 같은 패킷에 대한 중복된 ACK를 수신하게 되므로, NAK와 같은 상황임을 확인하여 중복된 ACK의 다음 패킷을 재전송한다.


## `rdt3.0`
`rdt3.0`은 조금 더 시궁창이다. 비트 오류에 이어 손실까지 일어나는 상황을 가정하기 때문이다. 즉, 통째로 날려먹는다 이소리다. 우리는 앞서 생각해본 기능에 더해, 패킷 손실의 검출과 그에 대한 처리를 추가적으로 알아볼 필요가 있다.

기본적으로, 패킷 손실의 검출과 복구는 송신자에게 그 책임을 둔다. 만약 송신자가 수신자에게 보낼 패킷 또는 수신자의 패킷에 대한 ACK를 잃어버렸다면, 수신자로부터 아무런 응답을 받을 수 없을 것이다. 송신자는 패킷을 잃어버렸다고 판단하기에 충분한 시간을 기다린 후 이를 재전송할 수 있다.

![](/imgs/network/net29.png)

여기서 얼마나 기다려야 하는지가 문젠데, 간단히 생각해보면 (경로에서의 일부 버퍼링을 고려하여) 패킷이 오가는 데 걸리는 시간에 패킷 처리에 걸리는 시간을 더한 것으로 설정할 수 있다. 즉, RTT + L(패킷 길이)/R(전송률)이다. 다만 worst-case에서의 시간을 예상하는 것도, 매번 그 최악의 시간을 기다리는 것도 꽤 곤란한 문제다. 하지만 그럼에도 실제로 적절히 시간을 선택하여 대기하고, 타임아웃 시 재전송하는 방식을 택한다. 이러한 stop-and-wait 방식에선, 응답이 제대로 오거나 타임아웃될 때까지 송신자는 대기해야 한다.

그럼 이렇게 고안된 방식은 어느 정도의 퍼포먼스를 가질까? Utilization(U, 이용률)을 이용해 퍼포먼스를 정의해보자. 즉, 전체 시간에서 실제로 비트를 (내부에서) 전송하는 데 사용하는 시간을 확인할 것이다. L/R을 0.008, RTT를 30 정도로 잡으면

    U_sender = (L/R) / (RTT+L/R) = 0.00027

과 같은 쓰레기틱한 이용률이 나온다. 와우. 송신자는 저 정도의 비율로만 바쁘게 움직였고, 나머지는 탱자탱자 놀았다는 얘기가 된다. 

### Pipelining
우리는 이러한 성능 저하를 파이프라이닝(pipelining)을 통해 어느 정도 개선해볼 수 있다. Computer architecture에서 접한 개념이니 아마 익숙할 것이다. 아무튼 파이프라이닝을 적용하여, 다수의 패킷을 한꺼번에 보내고 대기할 수 있다. 아까와 같은 상황에 파이프라이닝으로 3개의 패킷을 보낸다면 이용률(utilization)은 세 배로 늘어날 것이다.

![](imgs/network/net30.png)

아무튼 파이프라이닝에서도 패킷의 손실 및 손상에 대처하는 방법이 필요한테, 그것에 대한 approach로 Go-Back-N과 Selective-Repeat가 있다.

### Go-Back-N(GBN)
GBN은 ACK 되지 않은 가장 오래된 패킷의 seqnum(`base`)와 전송되지 않은 패킷들 중 가장 작은 seqnum(`nextseqnum`), 가장 큰 seqnum(`end`)을 기준으로 전체 패킷을 분할하면 다음과 같이 나눌 수 있다. 그리고 `base`로부터 ACK를 받지 못한 두 영역을 윈도우(window)라 부르고, 크기를 N이라고 하자.

- `[0, base-1]` : 전송되고 ACK 또한 받은 패킷
- `[base, nextseqnum-1]` : 전송되었으나 아직 ACK를 받지 못한 패킷
- `[nextseqnum, end-1]` : 전송되지 않은 패킷

![](/imgs/network/net31.png)

이러한 상황에서, GBN 프로토콜은 윈도우의 크기, 즉 ACK를 대기하는 패킷의 집합 크기를 N으로 제한한다. 여기서, 송신자는 가장 오래된 unACKed 패킷에 대한 타이머를 가지고 있어, 타이머 만료시 모든 unACKed 패킷을 재전송한다. 패킷과 ACK는 모두 순서에 맞춰서 전송되며, 앞 패킷에 손실이 발생했다면 뒷쪽 패킷이 제대로 전송되었더라도 그것은 버려진다.

수신자는 각각에 대해 ACK를 보낼 필요 없이, 가장 뒤쪽의 seqnum을 가진 패킷에 대한 ACK를 보내, 이전의 패킷이 잘 수신되었음을 알린다. Cumulative ACK라고 한다.

![](/imgs/network/net32.png)

GBN 프로토콜이 적용된 FSM이 textbook에 나와있다. 보고싶으면 보자.

### Selective Repeat(SR)
GBN은 불필요한 패킷 전송이 많아질 수 있다는 단점이 있다. SR 프로토콜은 손실/손상된 것으로 의심되는 패킷만을 송신자가 재전송해서 그 효율성을 높인다. 여기에도 윈도우의 개념이 있어, N 개의 unACKed 패킷만을 허용한다. GBN과는 각각의 패킷에 대한 ACK를 주고 받아야한다는 점, 각 unACKed 패킷에 대한 타이머를 가지고 있어야한다는 점에서 다르다.

SR 프로토콜에서, 수신자는 (앞 패킷이 손실되는 등의 이유로) 순서가 맞지 않는(out-of-order) 패킷을 discard하지 않고 버퍼에 저장한다. 손실된 패킷은 이후 재전송될 것인데, 재전송으로 인해 패킷이 순서가 맞게 된다면(in-order) 그 때 버퍼에 있는 패킷들을 포함하여 데이터를 전달한다. SR은 아래와 같은 방식으로 동작할 것이다.

![](/imgs/network/net33.png)

하지만 SR 프로토콜에서 발생할 수 있는 몇 가지 문제 상황이 있다. 수신자는 아래의 두 상황을 구분하지 못한다. 왜냐? 자기는 주어진 패킷을 잘 받고, (비록 도달하진 못했지만) ACK를 보냈다. 그리고 마지막의 두 seqnum이 동일해서, 이것이 재전송된 패킷인지 새로 보내진 패킷인지 구분할 수 없다. 보통 이런 문제는 윈도우의 크기가 너무 클 때의 문제로, 윈도우 크기를 전체의 절반 이하로 줄이면 어느 정도 해결된다. 또는, 이미 수신된 패킷을 재확인하는 과정도 필요할 것이다.

## Summary
지금까지 신뢰적인(reliable) data transfer를 위한 다양한 측면에서의 매커니즘을 알아보았다.

- 체크섬(checksum)은 패킷 내의 비트 오류(반전)를 발견하기 위해 사용된다. 
- 타이머(timer)의 도입으로 각각의 패킷에 대해 타임아웃 여부로 패킷 손실을 확인 및 처리한다.
- 순서 번호(sequence number)는 전송되는 데이터 패킷의 손실 및 중복 패킷 여부를 확인할 수 있도록 한다.
- 확인 응답(ACK)을 통해서 패킷의 정상적 수신 여부를 송신자가 알 수 있도록 하며, 이는 개별적일 수도, 누적될(cumulative) 수도 있다.
- 파이프라이닝(pipelining)은 다수의 패킷을 전송함으로써 데이터 전송에서의 효율성과 퍼포먼스를 증가시킬 수 있다.


